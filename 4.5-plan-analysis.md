
## Executive Summary

The Feature 4.5 implementation plan is **fundamentally sound** and follows established architectural patterns from the codebase. It correctly identifies the gatekeeper pattern from Stage 5 and applies it appropriately to the Phase A/Phase B boundary. However, the plan contains **three critical gaps** and **several medium-risk issues** that must be addressed to ensure production readiness.

**Overall Assessment:** ✅ **APPROVE WITH CRITICAL MODIFICATIONS**

**Key Strength:** The plan correctly recognizes this is a high-stakes architectural boundary between narrative design (Phase A) and production execution (Phase B), warranting rigorous validation.

**Primary Concern:** The plan underestimates the complexity of the auto-save/lock race condition and lacks explicit scene status transition logic, both of which could lead to data corruption or downstream pipeline failures.

---

## Table of Contents

1. Critical Flaws and High-Risk Issues
2. Medium-Level Design Gaps
3. What Is Solid and Well-Designed
4. Recommendations for Open Questions
5. Implementation Priority Recommendations
6. Testing Requirements

---

## 1. Critical Flaws and High-Risk Issues

### 1.1 Auto-Save Race Condition (HIGH RISK - MUST FIX)

**The Flaw:**

The plan acknowledges the debounced auto-save (800ms per Phase 4 Status, not 500ms as referenced in the too-basic analysis) but provides an incomplete solution. The proposed approach in Task 5 (line 248):

```typescript
if (pendingUpdates.size > 0) {
  await flushPendingSaves();
}
```

This is **insufficient** for several reasons:

1. **Asynchronous State Corruption**: The `pendingUpdates` Set tracks *which* shots have pending saves but doesn't prevent new edits from occurring during the flush operation
2. **Database Write Lag**: Even after the flush completes, there's a non-zero latency between the backend write and when the database transaction commits
3. **Optimistic UI Updates**: The frontend may show "saved" while the database write is still in flight

**The Risk:**

- User edits Shot #5 → triggers 800ms debounce timer
- User immediately clicks "Lock Shot List" (at T=100ms)
- Frontend flushes pending saves, sees empty `pendingUpdates` Set
- Lock validation runs against **stale shot data** (Shot #5 still has old value)
- Shot list locks with incomplete data OR validation fails with confusing error

**Real-World Scenario:**
A user is filling out the final required field ("camera") on the last shot. They type "Medium Shot" and immediately click the green "Lock & Proceed" button. The debounce timer hasn't fired yet, so the value isn't saved. The validation runs, sees an empty camera field, and shows an error: "Shot 20B: 'camera' is required" — but the user *just typed it in* and saw it in the UI. This creates user frustration and trust erosion.

**Required Fix:**

The lock handler must:
1. **Disable the UI immediately** (prevent new edits during lock attempt)
2. **Force a final, synchronous save of all dirty fields** (bypass debounce entirely)
3. **Wait for server confirmation** before proceeding to validation
4. **Use database-level locking** to prevent concurrent updates

**Implementation:**

```typescript
const handleLockShotList = async () => {
  setIsLocking(true);
  
  // Step 1: Prevent new edits
  setIsEditable(false);
  
  try {
    // Step 2: Force immediate save of ALL shots (bypass debounce)
    if (pendingUpdates.size > 0) {
      // Cancel all pending debounce timers
      debouncedSaveTimers.forEach(timer => clearTimeout(timer));
      
      // Batch update all dirty shots immediately
      const dirtyShots = Array.from(pendingUpdates).map(shotId => 
        shots.find(s => s.id === shotId)
      ).filter(Boolean);
      
      await shotService.batchUpdateShots(projectId, sceneId, dirtyShots);
      
      // Clear pending updates only after server confirms
      pendingUpdates.clear();
    }
    
    // Step 3: Brief delay to ensure database transaction commits
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // Step 4: Proceed with validation
    await lockShotList(false);
    
  } catch (error) {
    toast.error("Failed to save changes before locking");
    setIsEditable(true); // Re-enable editing on error
  } finally {
    setIsLocking(false);
  }
};
```

**Backend Enhancement:**

The backend lock endpoint should include a database-level check:

```sql
-- Ensure no concurrent updates are in flight
BEGIN;
SELECT * FROM shots WHERE scene_id = $1 FOR UPDATE;
-- Proceed with validation
COMMIT;
```

---

### 1.2 Scene Status Transition Logic Missing (HIGH RISK - MUST FIX)

**The Flaw:**

The plan adds `shot_list_locked_at` to the `scenes` table (Task 1, line 39) but **does not specify the corresponding `scene.status` update**. Line 131 in Task 3 mentions `status = 'shot_list_ready'` but this is never formally defined in the migration or validation logic.

**Evidence from Database Schema:**

From `database-schema-state-transition-matrix.md` (lines 1118-1120):

```sql
WHERE s.id = NEW.scene_id 
  AND s.status IN ('shot_list_ready', 'frames_locked', 'video_complete')
```

This shows `shot_list_ready` is a **valid scene status**, but the migration in Task 1 never defines it.

**The Risk:**

1. **Downstream Stage Blocking**: Stage 8 (Asset Assignment) likely checks `scene.status == 'shot_list_ready'` before allowing entry. If status isn't updated, users can't proceed even after locking
2. **Script Hub Display Errors**: The Stage 6 scene list (Feature 4.2) uses scene status to render UI indicators. A locked shot list with `status = 'draft'` will show confusing/incorrect state
3. **Invalidation Cascade Failures**: The deterministic invalidation system (database schema §7.3) relies on scene status to determine which downstream artifacts to mark as outdated

**Required Fix:**

**1. Migration Update (Task 1):**

```sql
-- Add shot list locking timestamp
ALTER TABLE scenes ADD COLUMN shot_list_locked_at TIMESTAMPTZ;

-- CRITICAL: Ensure 'shot_list_ready' is a valid status enum value
-- (If scene.status is a TEXT field with CHECK constraint, verify it includes this value)
-- (If it's an ENUM type, add the value if missing)

ALTER TABLE scenes 
  DROP CONSTRAINT IF EXISTS scenes_status_check;

ALTER TABLE scenes 
  ADD CONSTRAINT scenes_status_check 
  CHECK (status IN (
    'draft', 
    'script_pending',
    'dependencies_extracted',
    'shot_list_ready',      -- NEW: Status after Stage 7 lock
    'assets_assigned',
    'prompts_ready',
    'frames_locked', 
    'video_complete'
  ));

COMMENT ON COLUMN scenes.shot_list_locked_at IS 
  'Timestamp when shot list was validated and locked at Stage 7. 
   NULL means shot list is still editable. Non-NULL sets status to shot_list_ready.';
```

**2. Backend Lock Endpoint Update (Task 3, line 131):**

```typescript
// Update scene: shot_list_locked_at = NOW(), status = 'shot_list_ready'
const { error: updateError } = await supabase
  .from('scenes')
  .update({ 
    shot_list_locked_at: new Date().toISOString(),
    status: 'shot_list_ready',  // CRITICAL: Explicit status transition
    updated_at: new Date().toISOString()
  })
  .eq('id', sceneId)
  .eq('branch_id', activeBranchId)
  .is('shot_list_locked_at', null);  // Idempotency check

if (updateError) {
  return res.status(500).json({ error: 'Failed to lock scene' });
}
```

**3. Unlock Endpoint Status Rollback (Task 4):**

When unlocking, the status must revert to the previous valid state:

```typescript
// Determine previous status (likely 'draft' or 'dependencies_extracted')
const previousStatus = scene.dependencies_extracted_at ? 'dependencies_extracted' : 'draft';

await supabase
  .from('scenes')
  .update({ 
    shot_list_locked_at: null,
    status: previousStatus,  // Revert to pre-lock status
    updated_at: new Date().toISOString()
  })
  .eq('id', sceneId);
```

---

### 1.3 "Ghost Character" Problem - Character Name Validation (MEDIUM-HIGH RISK)

**The Flaw:**

The plan validates that character fields are **non-empty** (Task 2, line 70) but does not validate that character names **actually exist** in the project's asset pool.

**Evidence from PRD:**

From `project-overview.md` §2.3 (lines 105-112):

> Assets (Characters, Props, Wardrobe) must retain their state across scenes to ensure visual consistency.
> 1. **Master Asset Definition:** In Scene 1, the user defines the **Master Asset** (e.g., "John Doe, 30s, clean shirt").
> 2. **Inheritance Rule:** When moving to **Scene N+1**, the system defaults to the **final state** of the asset from **Scene N**.

This shows that characters are pre-defined in Stage 5 (Global Assets) and Scene N inherits from Scene N-1. If a user typos a character name in the shot list (e.g., "Jhon Doe" instead of "John Doe"), Stage 8 will fail to find the matching asset.

**The Risk:**

1. **Stage 8 Failure**: Asset Assignment stage cannot find the character → shows error or creates orphaned asset instance
2. **Continuity Breakdown**: User intended to reference the same character across scenes but typo creates a *new* character instance with no visual definition
3. **Cost Waste**: Regenerating shot list after discovering the error at Stage 8 wastes time and potentially API credits if LLM calls were made

**Recommendation:**

Implement **optional but recommended** character name validation:

**Level 1 (Minimum Viable):** Warning-level validation

```typescript
// In shotValidationService.ts

async function validateShotCoherence(shots: Shot[], projectId: string, sceneId: string): Promise<ValidationResult> {
  // Fetch expected characters from scene dependencies (already extracted in Stage 4)
  const scene = await fetchScene(sceneId);
  const expectedCharacters = scene.expected_characters || [];
  
  const warnings: ValidationWarning[] = [];
  
  shots.forEach(shot => {
    (shot.charactersForeground || []).forEach(charName => {
      // Fuzzy match against expected characters
      const isMatched = expectedCharacters.some(expected => 
        levenshteinDistance(charName.toLowerCase(), expected.toLowerCase()) < 2
      );
      
      if (!isMatched) {
        warnings.push({
          shotId: shot.shotId,
          shotOrder: shot.order,
          field: 'charactersForeground',
          message: `Character "${charName}" not found in scene dependencies. Did you mean "${findClosestMatch(charName, expectedCharacters)}"?`,
          severity: 'warning'
        });
      }
    });
  });
  
  return { valid: warnings.length === 0, errors: [], warnings };
}
```

**Level 2 (Recommended for Future Enhancement):** Cross-reference with Stage 5 master assets

Once the project has completed Stage 5, validate against the `project_assets` table:

```typescript
// Fetch master character assets from Stage 5
const { data: projectAssets } = await supabase
  .from('project_assets')
  .select('name')
  .eq('project_id', projectId)
  .eq('asset_type', 'character');

const masterCharacterNames = projectAssets.map(a => a.name);

// Validate shot characters against master list
```

**Implementation Decision:** Include Level 1 (scene dependency check) in Feature 4.5. Level 2 (global asset check) can be added later when Stage 5 integration is more mature.

---

## 2. Medium-Level Design Gaps

### 2.1 Minimum Shot Count Validation (MEDIUM RISK)

**The Gap:**

The plan validates individual shot fields but doesn't check if the scene has **at least one shot**. 

**Evidence from PRD:**

From `project-overview.md` §4.2 (Stage 7 description):

> The system must generate a shot-by-shot breakdown. Each shot defines: duration, camera movement, action, dialogue, characters present, setting details.

A scene with zero shots violates the core pipeline requirement.

**The Risk:**

User accidentally deletes all shots → clicks "Lock" → validation passes (no shots to validate) → scene marked as "ready" but has no production data → Stage 8 fails or shows empty state

**Recommended Fix:**

Add to `shotValidationService.ts` (Task 2):

```typescript
export function validateShots(shots: Shot[]): ValidationResult {
  const errors: ValidationError[] = [];
  const warnings: ValidationWarning[] = [];
  
  // CRITICAL: Check for empty shot list
  if (shots.length === 0) {
    errors.push({
      shotId: 'scene',
      shotOrder: -1,
      field: 'shot_count',
      message: 'Scene must have at least one shot. Use Stage 7 to generate a shot list.',
      severity: 'error'
    });
    return { valid: false, errors, warnings };
  }
  
  // ... rest of validation
}
```

---

### 2.2 Shot ID Uniqueness Validation (MEDIUM RISK)

**The Gap:**

Task 2 mentions checking for "duplicate shot IDs" (line 78) but doesn't specify how to handle user-edited shot IDs that create duplicates.

**The Risk:**

Shot IDs are used as keys in the UI and for frame generation tracking. Duplicate IDs cause:
1. React rendering errors (duplicate keys)
2. Frame assignment confusion in Stage 10
3. Video generation failures in Stage 12

**Recommended Fix:**

```typescript
// Check for duplicate shot IDs
const shotIdCounts = new Map<string, number>();
shots.forEach(shot => {
  const count = shotIdCounts.get(shot.shotId) || 0;
  shotIdCounts.set(shot.shotId, count + 1);
});

shotIdCounts.forEach((count, shotId) => {
  if (count > 1) {
    errors.push({
      shotId,
      shotOrder: -1,
      field: 'shotId',
      message: `Duplicate shot ID "${shotId}" found ${count} times. Each shot must have a unique ID.`,
      severity: 'error'
    });
  }
});
```

---

### 2.3 Total Scene Duration Bounds (LOW-MEDIUM RISK)

**The Gap:**

The plan checks total duration and warns if < 10s or > 120s (Task 5, lines 233-239), but these thresholds seem arbitrary and aren't documented in the PRD.

**Evidence from PRD:**

From `project-overview.md` §1.2:

> The visual boundaries (Start Frame / End Frame) of every **8-second shot** are locked using a cheaper image model.

This suggests the standard shot is ~8 seconds, so a 20-shot scene would be ~160 seconds (2.67 minutes). The 120s threshold may be too restrictive.

**Recommended Fix:**

1. Update warning thresholds based on project scope:

```typescript
// Calculate expected duration range based on shot count
const avgShotDuration = 8; // seconds (per PRD §1.2)
const expectedMin = shots.length * 4;  // Minimum 4s/shot
const expectedMax = shots.length * 15; // Maximum 15s/shot

if (totalDuration < expectedMin) {
  warnings.push({
    shotId: 'scene',
    shotOrder: -1,
    field: 'total_duration',
    message: `Scene duration (${totalDuration}s) is unusually short for ${shots.length} shots. Expected at least ${expectedMin}s.`,
    severity: 'warning'
  });
}
```

2. Add a **hard maximum** based on API limits (Veo3 has max video length constraints)

---

### 2.4 Unlock Endpoint Lacks Invalidation Cascade (MEDIUM RISK)

**The Gap:**

Task 4 (lines 186-187) checks if frames are generated before allowing unlock:

```typescript
if (scene.status > 'shot_list_ready') → return 400 "Cannot unlock: frames already generated"
```

But this is too restrictive. The database schema supports **deterministic invalidation cascades** (see `database-schema-state-transition-matrix.md` §7.3).

**Evidence from Database Schema:**

From lines 276-291:

```sql
CREATE TABLE invalidation_logs (
  id UUID PRIMARY KEY,
  branch_id UUID NOT NULL,
  invalidation_type TEXT NOT NULL, -- 'upstream_edit', 'asset_change', 'style_change'
  invalidated_stage_states UUID[], -- array of stage_state IDs now outdated
  invalidated_scenes UUID[],
  estimated_regen_cost NUMERIC(10,2)
);
```

This shows the system is designed to **allow** changes to locked stages by marking downstream artifacts as invalidated.

**Recommended Fix:**

Instead of blocking unlock when frames exist, **allow it** but:

1. Mark downstream artifacts (frames, videos) as `invalidated`
2. Log the invalidation event
3. Show user a cost estimate for regeneration

```typescript
// In unlock endpoint
if (scene.status >= 'frames_locked') {
  // Count frames and videos that will be invalidated
  const { data: frames } = await supabase
    .from('frames')
    .select('id')
    .in('shot_id', shotIds);
  
  const { data: videos } = await supabase
    .from('videos')
    .select('id')
    .in('shot_id', shotIds);
  
  // Calculate estimated regeneration cost
  const estimatedCost = (frames?.length || 0) * 0.05 + (videos?.length || 0) * 2.50;
  
  // Return warning instead of hard block
  return res.status(409).json({
    error: 'Unlocking will invalidate downstream artifacts',
    details: {
      framesAffected: frames?.length || 0,
      videosAffected: videos?.length || 0,
      estimatedCost,
      canProceed: true
    }
  });
}
```

Then frontend shows a destructive action modal:

```typescript
<AlertDialog>
  <AlertDialogContent>
    <AlertDialogHeader>
      <AlertDialogTitle>Warning: Invalidate Downstream Work?</AlertDialogTitle>
      <AlertDialogDescription>
        Unlocking this shot list will invalidate:
        - {framesAffected} generated frames
        - {videosAffected} rendered videos
        
        Estimated regeneration cost: ${estimatedCost}
        
        This action cannot be undone.
      </AlertDialogDescription>
    </AlertDialogHeader>
    <AlertDialogFooter>
      <AlertDialogCancel>Cancel</AlertDialogCancel>
      <AlertDialogAction onClick={() => unlockWithInvalidation()}>
        Unlock & Invalidate
      </AlertDialogAction>
    </AlertDialogFooter>
  </AlertDialogContent>
</AlertDialog>
```

---

## 3. What Is Solid and Well-Designed

### 3.1 Database Schema Design (EXCELLENT)

**Why It's Good:**

Adding `shot_list_locked_at` directly to the `scenes` table (Task 1) is the **correct architectural choice** for several reasons:

1. **Performance**: Avoids expensive joins with `stage_states` table just to check lock status
2. **Clarity**: Scene-level locking is a property of the scene entity, not a stage state
3. **Consistency**: Matches the pattern used for `dependencies_extracted_at` (Migration 011, Phase 4 Status)

**Evidence from Implementation:**

From `Phase-4-Status-Implementations.md` (lines 106-108):

```
- `dependencies_extracted_at` (timestamptz) - Added in Migration 011
```

This shows a precedent for adding stage-specific timestamps to the `scenes` table for performance-critical checks.

**Index Design:**

The partial index (Task 1, line 53) is well-designed:

```sql
CREATE INDEX idx_scenes_shot_list_locked ON scenes(shot_list_locked_at) 
  WHERE shot_list_locked_at IS NOT NULL;
```

This is a **partial index** that only indexes locked scenes, reducing index size and improving write performance (most scenes are unlocked most of the time).

---

### 3.2 Validation Service Separation (EXCELLENT)

**Why It's Good:**

Creating `shotValidationService.ts` (Task 2) instead of embedding validation logic in the route handler is **best practice** for several reasons:

1. **Testability**: Validation logic can be unit-tested independently
2. **Reusability**: Frontend can use same validation for client-side preview
3. **Maintainability**: Validation rules are centralized, not scattered across multiple files

**Evidence from Codebase:**

From `Phase-4-Status-Implementations.md` (lines 154-162):

```
Created: backend/src/services/sceneDependencyExtraction.ts

Features:
- LLM-based extraction of raw character names, location, props
- Reuses existing llm-client infrastructure
- Graceful error handling (never blocks scene persistence)
```

This shows the project already follows the service-oriented pattern for Stage 4, so applying it to Stage 7 is architecturally consistent.

---

### 3.3 Client-Side Validation Preview (GOOD)

**Why It's Good:**

Task 5 includes a `validateShotsLocally()` function (lines 208-242) that runs **before** the server call. This provides:

1. **Fast Feedback**: Users see validation errors instantly without network roundtrip
2. **Reduced Server Load**: Only well-formed shot lists reach the server
3. **Better UX**: Prevents "submit → error → fix → submit → error" loops

**Caveat:**

The client-side validation must be **identical** to server-side validation to avoid false negatives. Recommend extracting shared validation logic to a TypeScript file that both frontend and backend import (future enhancement).

---

### 3.4 Idempotent Lock Endpoint (GOOD)

**Why It's Good:**

Task 3 (line 163) mentions making the lock endpoint idempotent:

```
Prevent locking if already locked (idempotent: return success if already locked with same data)
```

This is important for:
1. **Network Reliability**: Retry-safe if the client loses connection after server locks but before response
2. **UX**: Clicking "Lock" multiple times doesn't cause errors
3. **Correctness**: Prevents double-locking race conditions

**Implementation Note:**

The check should use database-level `WHERE` clause:

```sql
UPDATE scenes 
SET shot_list_locked_at = NOW(), status = 'shot_list_ready'
WHERE id = $1 
  AND shot_list_locked_at IS NULL;  -- Only update if not already locked

RETURNING *;
```

If no rows are updated, check if the scene is already locked and return success.

---

### 3.5 Warning vs. Error Distinction (EXCELLENT)

**Why It's Good:**

The plan correctly distinguishes between:
- **Errors** (blocking): Missing required fields, invalid duration range (1-30s)
- **Warnings** (bypassable): Unusual duration (too short/long), total scene duration

This is **exactly right** for a creative tool. Filmmakers often intentionally use unusual durations (e.g., 2s for a quick cut, 15s for a lingering shot), so hard errors would be frustrating.

**Evidence from Response Structure:**

Task 3 (lines 146-159) defines clear HTTP status codes:
- 400 for errors (cannot proceed)
- 409 for warnings (can bypass with `force: true`)

This matches REST best practices and provides clear client-side handling.

---

## 4. Recommendations for Open Questions

### Question 1: Warnings vs. Errors (Duration)

**Recommendation:** **Warning (Bypassable)** for unusual durations (< 4s or > 12s), **Hard Error** for impossible durations (< 1s or > 30s)

**Reasoning:**

From `project-overview.md` §1.2:

> every **8-second shot** are locked using a cheaper image model

This suggests 8s is the *standard*, not the *requirement*. Creative decisions often require deviations:
- **Quick cuts**: 2-3 seconds (action sequences, montages)
- **Lingering shots**: 12-15 seconds (emotional beats, establishing shots)
- **Experimental**: 0.5s flicker cuts, 20s+ long takes

However, there are **physical API limits**:
- Veo3 has minimum video duration (likely 1-2s)
- Maximum duration for continuity (likely 30s before quality degrades)

**Implementation:**

```typescript
// Hard errors (un-bypassable)
if (shot.duration < 1) {
  errors.push({ message: 'Minimum duration is 1 second (API limit)' });
} else if (shot.duration > 30) {
  errors.push({ message: 'Maximum duration is 30 seconds (quality threshold)' });
}

// Warnings (bypassable)
else if (shot.duration < 4) {
  warnings.push({ 
    message: `Duration ${shot.duration}s is very short. Quick cuts work well for action but may feel rushed for dialogue. Is this intentional?`,
    severity: 'warning' 
  });
} else if (shot.duration > 12) {
  warnings.push({ 
    message: `Duration ${shot.duration}s is unusually long. Long takes can be powerful but risk viewer attention. Consider splitting into multiple shots.`,
    severity: 'warning' 
  });
}
```

---

### Question 2: Unlock Restrictions (Downstream Impact)

**Recommendation:** **Allow with Destructive Warning** if Stage 10+ is started, **Mark artifacts as invalidated** instead of deleting

**Reasoning:**

From `database-schema-state-transition-matrix.md` §3 (lines 28-33):

> ### **3. Deterministic Invalidation**
> * Upstream changes trigger cascading invalidation flags
> * Invalidated artifacts remain accessible but marked
> * Cost implications are calculated before commits

This shows the system is **designed** to handle upstream changes via invalidation, not deletion. Blocking changes would violate the core architecture.

**Implementation:**

The unlock endpoint should:

1. **Check downstream status:**
   ```typescript
   const hasDownstreamWork = scene.status >= 'frames_locked';
   ```

2. **If downstream work exists:**
   - Calculate impact (frames, videos affected)
   - Show cost estimate
   - Require explicit confirmation
   - Mark artifacts as `status: 'invalidated'` (not delete)
   - Log to `invalidation_logs` table

3. **If no downstream work:**
   - Simply unlock (no warning needed)

**UX Flow:**

```
User clicks "Unlock" → 
  If frames exist →
    Modal: "This will invalidate 47 frames and 12 videos (est. $125 to regenerate). Continue?"
    [Cancel] [Unlock & Invalidate]
  Else →
    Unlock immediately
```

**Database State After Unlock:**

```sql
-- Scene unlocked
UPDATE scenes SET shot_list_locked_at = NULL, status = 'draft';

-- Frames marked invalid (NOT deleted)
UPDATE frames SET status = 'invalidated' WHERE shot_id IN (...);

-- Invalidation logged
INSERT INTO invalidation_logs (branch_id, invalidation_type, invalidated_scenes, estimated_regen_cost)
VALUES (..., 'upstream_edit', [scene_id], 125.00);
```

This preserves data for potential rollback and provides audit trail.

---

### Question 3: Shot Coherence (Advanced Checks)

**Recommendation:** 

1. **Character Validation (Include in 4.5):** Validate against `scene.expected_characters` (already extracted in Stage 4)
2. **Dialogue Gaps (Future Enhancement):** Check for orphaned dialogue in script vs. shots
3. **Continuity Flags (Future Enhancement):** Validate flag consistency across shots

**Reasoning:**

**Priority 1: Character Validation**

This prevents the "ghost character" problem identified in §1.3. Since character names are already extracted in Stage 4 (per Feature 4.2), this is a **low-effort, high-value** addition.

**Implementation (Include in Feature 4.5):**

```typescript
// In shotValidationService.ts
export async function validateShotCoherence(
  shots: Shot[], 
  scene: Scene
): Promise<ValidationResult> {
  const warnings: ValidationWarning[] = [];
  const expectedCharacters = scene.expected_characters || [];
  
  shots.forEach(shot => {
    // Check foreground characters
    (shot.charactersForeground || []).forEach(charName => {
      const normalized = charName.toLowerCase().trim();
      const isExpected = expectedCharacters.some(expected => 
        expected.toLowerCase().trim() === normalized
      );
      
      if (!isExpected) {
        // Fuzzy match for typos
        const closestMatch = findClosestMatch(normalized, expectedCharacters);
        warnings.push({
          shotId: shot.shotId,
          shotOrder: shot.order,
          field: 'charactersForeground',
          message: `Character "${charName}" not found in scene script. Did you mean "${closestMatch}"?`,
          severity: 'warning'
        });
      }
    });
    
    // Same for background characters
    (shot.charactersBackground || []).forEach(charName => {
      // ... similar logic
    });
  });
  
  return { valid: true, errors: [], warnings };
}
```

**Priority 2: Dialogue Gaps (Future Enhancement)**

This is more complex and should be a **post-4.5 enhancement**:

```typescript
// Check if scene script contains dialogue that's missing from all shots
const sceneDialogue = extractDialogueFromScript(scene.script_excerpt);
const shotDialogue = shots.flatMap(s => s.dialogue || []);

sceneDialogue.forEach(line => {
  if (!shotDialogue.some(shotLine => similarity(line, shotLine) > 0.7)) {
    warnings.push({
      message: `Script dialogue "${line}" is not assigned to any shot`,
      severity: 'warning'
    });
  }
});
```

**Priority 3: Continuity Flags (Future Enhancement)**

This requires cross-shot analysis and is a **post-4.5 enhancement**:

```typescript
// Check for inconsistent continuity flags
// E.g., Shot 3 has "character_bloody" but Shot 4 doesn't (and should)
```

**Recommendation for 4.5:** Include **character validation only**. Defer dialogue gaps and continuity flags to a future feature enhancement once the basic locking mechanism is proven stable.

---

### Question 4: Validation Scope (Real-time vs. Gate)

**Recommendation:** **Hybrid Approach** (real-time indicators + gate validation)

**Reasoning:**

From a UX perspective, the best approach is:

1. **Real-time**: Show subtle visual indicators as user edits
   - Empty required field → red bottom border (not intrusive)
   - Invalid duration → yellow icon with tooltip
   - No toast notifications or blocking modals

2. **Gate**: Run full, strict validation at lock time
   - All checks (including coherence)
   - Server-side validation (source of truth)
   - Modal with all errors and warnings

**Implementation:**

**Real-time (Frontend Only):**

```typescript
// In Stage7ShotList.tsx
const getFieldValidationState = (shot: Shot, field: string): 'valid' | 'warning' | 'error' => {
  if (field === 'action' && !shot.action?.trim()) return 'error';
  if (field === 'camera' && !shot.camera?.trim()) return 'error';
  if (field === 'setting' && !shot.setting?.trim()) return 'error';
  
  if (field === 'duration') {
    if (shot.duration < 1 || shot.duration > 30) return 'error';
    if (shot.duration < 4 || shot.duration > 12) return 'warning';
  }
  
  return 'valid';
};

// In render:
<Input
  value={shot.action}
  onChange={handleChange}
  className={cn(
    getFieldValidationState(shot, 'action') === 'error' && 'border-b-2 border-b-red-500',
    getFieldValidationState(shot, 'action') === 'warning' && 'border-b-2 border-b-yellow-500'
  )}
/>
```

**Gate (Backend + Frontend):**

When user clicks "Lock & Proceed", run full validation (client-side preview first, then server-side authoritative check).

**Benefits:**

- **Real-time**: Reduces "validation shock" by surfacing issues during editing
- **Gate**: Ensures data integrity with authoritative server-side check
- **No annoyance**: Real-time indicators are subtle (colored borders), not disruptive (modals, toasts)

---

### Question 5: Force Lock (Bypass Rules)

**Recommendation:** **Bypass Warnings Only**

**Policy:**

| Validation Type | Can Force Lock? | Rationale |
|-----------------|-----------------|-----------|
| **Errors** | ❌ No | Data integrity violations (empty required fields, invalid duration ranges) |
| **Warnings** | ✅ Yes | Creative decisions (unusual durations, character name typos, total duration) |

**Implementation:**

```typescript
// Backend lock endpoint
if (validationResult.errors.length > 0) {
  // NEVER bypassable
  return res.status(400).json({
    error: 'Shot list validation failed',
    errors: validationResult.errors,
    canForce: false  // Explicitly mark as non-bypassable
  });
}

if (validationResult.warnings.length > 0 && !req.body.force) {
  // Bypassable with force=true
  return res.status(409).json({
    error: 'Shot list has warnings',
    warnings: validationResult.warnings,
    canForce: true  // User can bypass
  });
}

if (req.body.force && validationResult.warnings.length > 0) {
  // Log forced lock for audit trail
  await supabase.from('scenes').update({
    shot_list_locked_at: new Date().toISOString(),
    status: 'shot_list_ready',
    metadata: {
      ...scene.metadata,
      forcedLock: true,
      forcedLockWarnings: validationResult.warnings.map(w => w.message)
    }
  }).eq('id', sceneId);
}
```

**Audit Trail:**

Store forced lock info in `scene.metadata` JSONB field:

```json
{
  "forcedLock": true,
  "forcedLockWarnings": [
    "Shot 3A: Duration 2s is unusually short",
    "Character 'Jhon Doe' not found in scene dependencies"
  ],
  "forcedLockAt": "2026-01-30T14:23:11Z",
  "forcedLockBy": "user-uuid-123"
}
```

This provides transparency if issues arise in later stages.

---

## 5. Implementation Priority Recommendations

### Phase 1: Critical Fixes (Must Complete Before Any Testing)

**Duration:** 4-6 hours

1. ✅ **Fix auto-save race condition** (§1.1)
   - Add `setIsEditable(false)` to lock handler
   - Implement forced synchronous save
   - Add 100ms settle delay before validation

2. ✅ **Add scene status transition logic** (§1.2)
   - Update migration to include `shot_list_ready` status
   - Update lock endpoint to set status
   - Update unlock endpoint to revert status

3. ✅ **Add minimum shot count validation** (§2.1)
   - Error if `shots.length === 0`

4. ✅ **Add shot ID uniqueness check** (§2.2)
   - Error if duplicate shot IDs found

### Phase 2: High-Value Enhancements (Recommended for 4.5)

**Duration:** 3-4 hours

5. ✅ **Character name validation** (§1.3 + Question 3)
   - Warning-level check against `scene.expected_characters`
   - Fuzzy matching for typo suggestions

6. ✅ **Improved unlock with invalidation** (§2.4 + Question 2)
   - Remove hard block when frames exist
   - Show cost estimate
   - Mark downstream artifacts as invalidated

### Phase 3: Polish & Production Readiness (Complete Feature 4.5)

**Duration:** 2-3 hours

7. ✅ **Implement hybrid validation UX** (Question 4)
   - Real-time field indicators (colored borders)
   - Gate validation at lock time

8. ✅ **Force lock audit trail** (Question 5)
   - Store forced lock metadata
   - Show indicator in UI if scene was force-locked

9. ✅ **Update duration thresholds** (§2.3)
   - Dynamic thresholds based on shot count
   - Clear messaging for warnings

### Optional Enhancements (Post-4.5)

10. ⏳ **Dialogue gap detection** (Question 3)
11. ⏳ **Continuity flag validation** (Question 3)
12. ⏳ **Background dependency extraction** (performance optimization)

---

## 6. Testing Requirements

### 6.1 Unit Tests (Backend)

**Required Coverage:**

```typescript
// shotValidationService.test.ts
describe('shotValidationService', () => {
  describe('validateShots', () => {
    it('should error on empty shot list', () => {
      const result = validateShots([]);
      expect(result.valid).toBe(false);
      expect(result.errors[0].message).toContain('at least one shot');
    });
    
    it('should error on missing required fields', () => {
      const shot = { shotId: '1A', duration: 8, action: '', camera: 'MS', setting: 'INT' };
      const result = validateShots([shot]);
      expect(result.errors).toContainEqual(
        expect.objectContaining({ field: 'action', severity: 'error' })
      );
    });
    
    it('should error on duration out of bounds', () => {
      const shot = { shotId: '1A', duration: 0.5, action: 'Walk', camera: 'MS', setting: 'INT' };
      const result = validateShots([shot]);
      expect(result.errors).toContainEqual(
        expect.objectContaining({ field: 'duration', severity: 'error' })
      );
    });
    
    it('should warn on unusual duration', () => {
      const shot = { shotId: '1A', duration: 2, action: 'Walk', camera: 'MS', setting: 'INT' };
      const result = validateShots([shot]);
      expect(result.warnings).toContainEqual(
        expect.objectContaining({ field: 'duration', severity: 'warning' })
      );
    });
    
    it('should error on duplicate shot IDs', () => {
      const shots = [
        { shotId: '1A', duration: 8, action: 'Walk', camera: 'MS', setting: 'INT' },
        { shotId: '1A', duration: 6, action: 'Talk', camera: 'CU', setting: 'INT' }
      ];
      const result = validateShots(shots);
      expect(result.errors).toContainEqual(
        expect.objectContaining({ field: 'shotId' })
      );
    });
  });
});
```

### 6.2 Integration Tests (API Endpoints)

**Required Coverage:**

```typescript
// projects.test.ts
describe('POST /api/projects/:id/scenes/:sceneId/shots/lock', () => {
  it('should lock shot list with valid shots', async () => {
    // Setup: Create project, scene, shots
    const res = await request(app)
      .post(`/api/projects/${projectId}/scenes/${sceneId}/shots/lock`)
      .set('Authorization', `Bearer ${token}`)
      .send({ force: false });
    
    expect(res.status).toBe(200);
    expect(res.body.scene.shotListLockedAt).toBeTruthy();
    expect(res.body.scene.status).toBe('shot_list_ready');
  });
  
  it('should return 400 on validation errors', async () => {
    // Setup: Scene with invalid shots (missing required field)
    const res = await request(app)
      .post(`/api/projects/${projectId}/scenes/${sceneId}/shots/lock`)
      .set('Authorization', `Bearer ${token}`);
    
    expect(res.status).toBe(400);
    expect(res.body.errors).toBeDefined();
    expect(res.body.canForce).toBe(false);
  });
  
  it('should return 409 on validation warnings', async () => {
    // Setup: Scene with unusual duration
    const res = await request(app)
      .post(`/api/projects/${projectId}/scenes/${sceneId}/shots/lock`)
      .set('Authorization', `Bearer ${token}`);
    
    expect(res.status).toBe(409);
    expect(res.body.warnings).toBeDefined();
    expect(res.body.canForce).toBe(true);
  });
  
  it('should lock with force=true bypassing warnings', async () => {
    const res = await request(app)
      .post(`/api/projects/${projectId}/scenes/${sceneId}/shots/lock`)
      .set('Authorization', `Bearer ${token}`)
      .send({ force: true });
    
    expect(res.status).toBe(200);
    // Verify metadata.forcedLock is set
  });
  
  it('should be idempotent (locking already-locked scene succeeds)', async () => {
    // Lock once
    await request(app)
      .post(`/api/projects/${projectId}/scenes/${sceneId}/shots/lock`)
      .set('Authorization', `Bearer ${token}`);
    
    // Lock again
    const res = await request(app)
      .post(`/api/projects/${projectId}/scenes/${sceneId}/shots/lock`)
      .set('Authorization', `Bearer ${token}`);
    
    expect(res.status).toBe(200);
  });
});
```

### 6.3 Manual Testing Scenarios

**Critical User Flows:**

1. **Happy Path:**
   - Fill out all required fields
   - Click "Lock & Proceed"
   - Verify scene status updates to `shot_list_ready`
   - Verify all input fields become disabled
   - Verify "Lock" button changes to "Locked" with lock icon

2. **Validation Error Path:**
   - Leave a required field empty
   - Click "Lock & Proceed"
   - Verify modal shows error with field name
   - Verify "Lock Anyway" button is NOT present
   - Fill field and retry
   - Verify success

3. **Validation Warning Path:**
   - Set shot duration to 2 seconds
   - Click "Lock & Proceed"
   - Verify modal shows warning (not error)
   - Verify "Lock Anyway" button IS present
   - Click "Lock Anyway"
   - Verify force lock succeeds with metadata flag

4. **Auto-Save Race Condition:**
   - Edit the final required field (e.g., type "Medium Shot" in camera field)
   - **Immediately** click "Lock & Proceed" (< 800ms)
   - Verify the edit is saved before validation runs
   - Verify lock succeeds

5. **Unlock with Frames:**
   - Lock shot list
   - Progress to Stage 10, generate frames
   - Return to Stage 7
   - Click "Unlock"
   - Verify modal shows frame count and cost estimate
   - Click "Unlock & Invalidate"
   - Verify frames marked as invalidated (not deleted)

6. **Character Name Typo:**
   - Scene has `expected_characters: ['John Doe', 'Jane Smith']`
   - In shot, type `charactersForeground: ['Jhon Doe']` (typo)
   - Click "Lock & Proceed"
   - Verify warning: "Did you mean 'John Doe'?"
   - Verify can bypass with "Lock Anyway"

---

## Appendix A: Implementation Checklist

### Task 1: Database Migration ✅ MODIFY

- [x] Add `shot_list_locked_at` column to scenes
- [ ] **ADD:** Update `scenes.status` CHECK constraint to include `'shot_list_ready'`
- [x] Add index on `shot_list_locked_at`
- [x] Add comments

### Task 2: Validation Service ✅ ENHANCE

- [x] Create `shotValidationService.ts`
- [x] Implement required field validation
- [x] Implement duration validation (1-30s hard limit, 4-12s warning)
- [ ] **ADD:** Minimum shot count check (≥ 1 shot)
- [ ] **ADD:** Shot ID uniqueness check
- [ ] **ADD:** Character name validation against `scene.expected_characters`
- [x] Define ValidationResult interface

### Task 3: Lock Endpoint ✅ ENHANCE

- [x] Create `POST /api/projects/:id/scenes/:sceneId/shots/lock`
- [x] Verify ownership and permissions
- [x] Validate shots with service
- [ ] **MODIFY:** Explicitly set `status = 'shot_list_ready'` in database update
- [ ] **ADD:** Store `metadata.forcedLock` if `force: true` used
- [x] Return validation errors (400) or warnings (409)
- [x] Implement idempotent check

### Task 4: Unlock Endpoint ✅ ENHANCE

- [x] Create `POST /api/projects/:id/scenes/:sceneId/shots/unlock`
- [ ] **MODIFY:** Remove hard block when frames exist
- [ ] **ADD:** Calculate invalidation cost (frame count × $0.05 + video count × $2.50)
- [ ] **ADD:** Return 409 with cost estimate if downstream work exists
- [ ] **ADD:** Mark frames/videos as `status: 'invalidated'` when unlocking
- [ ] **ADD:** Log to `invalidation_logs` table
- [ ] **MODIFY:** Revert scene status to previous state (likely `'draft'` or `'dependencies_extracted'`)

### Task 5: Frontend Validation ✅ ENHANCE

- [x] Add validation state hooks
- [x] Implement `validateShotsLocally()`
- [ ] **ADD:** Real-time field validation (colored borders)
- [ ] **MODIFY:** Lock handler to force synchronous save before validation
- [ ] **ADD:** `setIsEditable(false)` during lock attempt
- [ ] **ADD:** 100ms settle delay after forced save

### Task 6: Warning Modal ✅ ENHANCE

- [x] Create ValidationWarningDialog component
- [x] Display errors and warnings separately
- [ ] **MODIFY:** Hide "Lock Anyway" button if `canForce: false`
- [ ] **ADD:** Show cost estimate for unlock invalidation

### Task 7: Shot Service ✅

- [x] Add `lockShotList()` method
- [x] Add `unlockShotList()` method
- [x] Handle error responses with status codes

### Task 8: Visual Indicators ✅

- [x] Fetch scene lock status
- [x] Disable editing when locked
- [x] Show lock banner
- [x] Add "Unlock" button

### Task 9: Type Updates ✅

- [x] Add `shotListLockedAt` to Scene interface
- [x] Update scene transformation

### Task 10: Backend Scene Fetch ✅

- [x] Add `shot_list_locked_at` to SELECT queries

### Task 11: Testing ✅ ENHANCE

- [x] Manual testing checklist
- [ ] **ADD:** Unit tests for validation service
- [ ] **ADD:** Integration tests for lock/unlock endpoints
- [ ] **ADD:** Manual test for auto-save race condition
- [ ] **ADD:** Manual test for character name validation
- [ ] **ADD:** Manual test for unlock with invalidation

---

## Appendix B: SQL Snippets for Reference

### Complete Migration 014

```sql
-- Migration 014: Add shot list locking to scenes table
-- Purpose: Enable Stage 7 shot list validation and gatekeeper functionality

BEGIN;

-- Add shot list locking timestamp
ALTER TABLE scenes ADD COLUMN shot_list_locked_at TIMESTAMPTZ;

COMMENT ON COLUMN scenes.shot_list_locked_at IS 
  'Timestamp when shot list was validated and locked at Stage 7. 
   NULL means shot list is still editable. Non-NULL sets status to shot_list_ready.';

-- Create partial index for performance (only index locked scenes)
CREATE INDEX idx_scenes_shot_list_locked ON scenes(shot_list_locked_at) 
  WHERE shot_list_locked_at IS NOT NULL;

-- CRITICAL: Ensure 'shot_list_ready' is a valid scene status
-- (Adjust this based on your current status column definition)

-- If status is TEXT with CHECK constraint:
ALTER TABLE scenes 
  DROP CONSTRAINT IF EXISTS scenes_status_check;

ALTER TABLE scenes 
  ADD CONSTRAINT scenes_status_check 
  CHECK (status IN (
    'draft',
    'script_pending',
    'dependencies_extracted',
    'shot_list_ready',      -- NEW: Status after Stage 7 lock
    'assets_assigned',
    'prompts_ready',
    'frames_locked',
    'video_complete'
  ));

-- If status is ENUM type (uncomment if applicable):
-- ALTER TYPE scene_status ADD VALUE IF NOT EXISTS 'shot_list_ready';

COMMIT;

-- Rollback instructions:
-- BEGIN;
-- ALTER TABLE scenes DROP COLUMN shot_list_locked_at;
-- DROP INDEX IF EXISTS idx_scenes_shot_list_locked;
-- -- Revert status constraint to previous values
-- COMMIT;
```

### Lock Endpoint Query

```sql
-- Lock shot list (idempotent, transaction-safe)
BEGIN;

-- Update scene (only if not already locked)
UPDATE scenes 
SET 
  shot_list_locked_at = NOW(),
  status = 'shot_list_ready',
  updated_at = NOW()
WHERE 
  id = $1                          -- scene_id
  AND branch_id = $2               -- active_branch_id
  AND shot_list_locked_at IS NULL  -- not already locked
RETURNING *;

-- If zero rows updated, check if already locked
SELECT id, shot_list_locked_at, status
FROM scenes
WHERE id = $1 AND shot_list_locked_at IS NOT NULL;

COMMIT;
```

### Unlock with Invalidation Query

```sql
-- Unlock shot list and invalidate downstream artifacts
BEGIN;

-- Get all shots for this scene
SELECT id FROM shots WHERE scene_id = $1;

-- Mark frames as invalidated
UPDATE frames 
SET status = 'invalidated'
WHERE shot_id IN (SELECT id FROM shots WHERE scene_id = $1);

-- Mark videos as invalidated
UPDATE videos
SET status = 'invalidated'
WHERE shot_id IN (SELECT id FROM shots WHERE scene_id = $1);

-- Log invalidation event
INSERT INTO invalidation_logs (
  branch_id,
  invalidation_type,
  invalidated_scenes,
  estimated_regen_cost
) VALUES (
  $2,                              -- branch_id
  'upstream_edit',
  ARRAY[$1],                       -- scene_id
  $3                               -- calculated cost
);

-- Unlock scene
UPDATE scenes 
SET 
  shot_list_locked_at = NULL,
  status = 'draft',  -- or 'dependencies_extracted' based on previous state
  updated_at = NOW()
WHERE id = $1;

COMMIT;
```

---

## Final Recommendations

1. **Address Critical Fixes First**: Complete Phase 1 (§5) before any testing or deployment
2. **Test Auto-Save Race Condition Thoroughly**: This is the highest-risk edge case
3. **Document Force Lock Policy**: Make it clear to users what warnings can be bypassed
4. **Monitor Invalidation Costs**: Track how often users unlock after frames are generated
5. **Iterate on Character Validation**: Start with simple warning, enhance with fuzzy matching later

**Overall Verdict:** The plan is **solid with critical modifications required**. Once the auto-save race condition and scene status transitions are addressed, this feature will provide a robust gatekeeper for the Phase A → Phase B boundary.

---

**Document Status:** ✅ COMPLETE  
**Next Step:** Review this analysis, prioritize fixes from Phase 1, and begin implementation with modified plan.
