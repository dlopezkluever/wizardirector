

## Recommended Implementation Order

### **Phase 1: Foundation (Types & Core Parsing)**
**Group together: Tasks 1, 2, 4**

**Rationale**: These are tightly coupled and must be implemented together to test the extraction pipeline.

- **Task 1** (Types) — Must be first; everything depends on correct types
- **Task 2** (Parser) — Needed by extraction
- **Task 4** (Extraction Logic) — Uses the parser and generates scene numbers

**Why together**: You can't test extraction without the parser, and the parser needs correct types. Test extraction end-to-end with various script formats.

---

### **Phase 2: Slug Generation**
**Task 3** (Slug Generation)

**Rationale**: Depends on Phase 1 (needs parsed heading components and scene numbers from extraction). Can be tested independently once extraction works.

---

### **Phase 3: Backend API (Read & Write)**
**Group together: Tasks 5, 6.5**

**Rationale**: Both touch the backend persistence layer and should be tested together.

- **Task 5** (GET endpoint) — Fetching scenes
- **Task 6.5** (Scene ID Stability in PUT endpoint) — Writing scenes with ID preservation

**Why together**: Test the full persistence flow: write with ID stability, then read back. The GET endpoint is simpler and can be done first, but both should be completed before frontend integration.

---

### **Phase 4: Frontend Service Layer**
**Task 6** (Scene Service)

**Rationale**: Depends on Phase 3 (API endpoints) and Phase 1 (extraction for preview). This is the frontend abstraction layer.

**Note**: The `previewScenes()` method uses `extractScenes()` from Phase 1, so Phase 1 must be complete.

---

### **Phase 5: UI Integration (Gate Approach)**
**Task 7** (Stage 4/5 Transition Logic)

**Rationale**: Depends on Phase 4 (sceneService) and Phase 3 (backend stability logic). This is the integration point that ties everything together.

**Critical**: This implements the "Gate Approach" and must work with all previous phases.

---

### **Phase 6: Stage 6 Integration**
**Task 8** (Replace Mock Data in Stage 6)

**Rationale**: Depends on Phase 4 (sceneService) and Phase 3 (GET endpoint). Can be done independently after the service layer exists.

---

### **Phase 7: Testing**
**Task 9** (Tests)

**Rationale**: Write tests throughout, but finalize comprehensive tests after core logic is complete. Can be done incrementally:
- Unit tests for Phase 1 (parser, extraction) during/after Phase 1
- Integration tests for Phase 3 (API endpoints) during/after Phase 3
- E2E tests for Phase 5 (Gate Approach) after Phase 5

---

## Summary Table

| Phase | Tasks | Dependencies | Can Test? |
|-------|-------|--------------|-----------|
| **1** | 1, 2, 4 | None (foundation) | ✅ Yes - extraction pipeline |
| **2** | 3 | Phase 1 | ✅ Yes - slug generation |
| **3** | 5, 6.5 | Phase 1 (types) | ✅ Yes - API persistence |
| **4** | 6 | Phase 1, 3 | ✅ Yes - service layer |
| **5** | 7 | Phase 1, 3, 4 | ✅ Yes - full Gate flow |
| **6** | 8 | Phase 3, 4 | ✅ Yes - Stage 6 display |
| **7** | 9 | All phases | ✅ Yes - comprehensive coverage |

## Critical Path Dependencies

1. **Task 1 → Everything** (types are foundational)
2. **Tasks 2 + 4 → Task 3** (slug needs parsed data and scene numbers)
3. **Tasks 1 + 3 + 4 → Task 6** (service needs types, extraction, and slugs)
4. **Tasks 5 + 6.5 → Task 6** (service needs API endpoints)
5. **Task 6 → Task 7** (Gate Approach uses sceneService)
6. **Task 6 → Task 8** (Stage 6 uses sceneService)

## Testing Strategy Recommendation

- **After Phase 1**: Test extraction with various script formats (DAY/NIGHT, edge cases)
- **After Phase 2**: Test slug uniqueness with duplicate locations
- **After Phase 3**: Test API endpoints (GET/PUT with ID stability scenarios)
- **After Phase 4**: Test preview functionality in isolation
- **After Phase 5**: Test full Gate Approach flow (preview → commit → branch warnings)
- **After Phase 6**: Test Stage 6 displays real data correctly

This order ensures each phase can be tested before moving to the next, and dependencies are satisfied.