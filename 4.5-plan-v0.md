I'll create a detailed implementation plan for Feature 4.5: Shot List Validation & Locking. Let me first examine the relevant files to understand the current state and patterns to follow.

[6 tools called]

Let me gather more context about the validation patterns and requirements.

[12 tools called]

Perfect! I now have comprehensive context from the codebase. Let me create a detailed implementation plan for Feature 4.5: Shot List Validation & Locking.

## Feature 4.5: Shot List Validation & Locking - Detailed Implementation Plan

Based on my analysis of the codebase, here's a comprehensive plan broken down into tasks:

---

## Overview

**Goal**: Implement a gatekeeper that validates shot list completeness, enforces quality standards, and locks the shot list before allowing users to proceed to Stage 8 (Asset Assignment).

**Pattern to Follow**: Stage 5 Assets validation/locking (lines 364-397 in `Stage5Assets.tsx`) serves as the architectural template.

**Key Files to Modify**:
- Frontend: `src/components/pipeline/Stage7ShotList.tsx`
- Backend: `backend/src/routes/projects.ts` (new endpoints)
- Database: New migration for `shot_list_locked_at` field
- Types: `src/types/scene.ts` (if needed)

---

## Task Breakdown

### **Task 1: Database Schema Migration**
**Purpose**: Add fields to track shot list locking

**File**: `backend/migrations/014_add_shot_list_locking.sql`

**Changes**:
1. Add `shot_list_locked_at` column to `scenes` table (TIMESTAMPTZ, nullable)
2. Add comment explaining this is set when shot list validation passes and user locks Stage 7
3. Add index on `shot_list_locked_at` for queries filtering locked scenes
4. Include rollback SQL in comments

**Example Structure**:
```sql
-- Add shot list locking timestamp
ALTER TABLE scenes ADD COLUMN shot_list_locked_at TIMESTAMPTZ;

COMMENT ON COLUMN scenes.shot_list_locked_at IS 
  'Timestamp when shot list was validated and locked at Stage 7. 
   NULL means shot list is still editable. Non-NULL prevents shot edits.';

CREATE INDEX idx_scenes_shot_list_locked ON scenes(shot_list_locked_at) 
  WHERE shot_list_locked_at IS NOT NULL;

-- Rollback:
-- ALTER TABLE scenes DROP COLUMN shot_list_locked_at;
-- DROP INDEX IF EXISTS idx_scenes_shot_list_locked;
```

---

### **Task 2: Backend Validation Service**
**Purpose**: Create reusable shot validation logic

**File**: `backend/src/services/shotValidationService.ts` (NEW)

**Features**:
1. **Field Validation**:
   - Required fields: `action`, `setting`, `camera` (non-empty strings)
   - Duration: 1-30 seconds (warn if outside typical 6-10 second range)
   - Optional fields: `dialogue`, `charactersForeground`, `charactersBackground`, `continuityFlags`

2. **Shot Coherence Checking**:
   - All shots have sequential `shot_order` (0, 1, 2, ...)
   - Total duration reasonable (warn if < 10s or > 120s per scene)
   - Shot IDs follow convention (e.g., `1A`, `1B`, `1C`)
   - No duplicate shot IDs

3. **Validation Result Structure**:
```typescript
interface ValidationResult {
  valid: boolean;
  errors: ValidationError[];
  warnings: ValidationWarning[];
}

interface ValidationError {
  shotId: string;
  shotOrder: number;
  field: string;
  message: string;
  severity: 'error' | 'warning';
}
```

4. **Export**:
   - `validateShots(shots: Shot[]): ValidationResult`
   - `shotValidationService` singleton

**Example Validation Logic**:
- Error: Missing required field → `"Shot 3A: 'action' is required"`
- Error: Duration out of bounds → `"Shot 3B: Duration must be between 1-30 seconds"`
- Warning: Duration unusual → `"Shot 3C: Duration 2s is unusually short (typical: 6-10s)"`
- Warning: Total duration → `"Scene duration 145s is very long (typical: 30-90s)"`

---

### **Task 3: Backend Locking Endpoint**
**Purpose**: Validate and lock shot list, update scene status

**File**: `backend/src/routes/projects.ts`

**New Endpoint**: `POST /api/projects/:id/scenes/:sceneId/shots/lock`

**Request Body** (optional):
```typescript
{
  force?: boolean; // Skip warnings (not errors) if true
}
```

**Logic**:
1. Verify project ownership and scene belongs to active branch
2. Check scene is not already locked (`shot_list_locked_at IS NULL`)
3. Fetch all shots for scene
4. Validate shots with `shotValidationService.validateShots()`
5. If validation errors exist → return 400 with error details
6. If validation warnings exist and `force !== true` → return 409 with warnings
7. If valid (or forced):
   - Update scene: `shot_list_locked_at = NOW()`, `status = 'shot_list_ready'`
   - Return success with locked scene data

**Response Structure**:
```typescript
// Success (200)
{
  success: true,
  scene: {
    id: string,
    status: 'shot_list_ready',
    shotListLockedAt: string,
    shotCount: number
  }
}

// Validation Errors (400)
{
  error: 'Shot list validation failed',
  errors: ValidationError[]
}

// Validation Warnings (409)
{
  error: 'Shot list has warnings',
  warnings: ValidationWarning[],
  canForce: true
}
```

**Security**:
- Check ownership: scene → branch → project → user_id
- Prevent locking if already locked (idempotent: return success if already locked with same data)
- Transaction: Use Supabase transaction if updating multiple tables

---

### **Task 4: Backend Unlock Endpoint (Optional but Recommended)**
**Purpose**: Allow unlocking shot list with confirmation

**File**: `backend/src/routes/projects.ts`

**New Endpoint**: `POST /api/projects/:id/scenes/:sceneId/shots/unlock`

**Request Body**:
```typescript
{
  reason?: string; // Audit trail
}
```

**Logic**:
1. Verify ownership
2. Check scene is locked (`shot_list_locked_at IS NOT NULL`)
3. Check no downstream dependencies (frames not generated yet)
   - Query: scenes table for `frames_locked`, `video_complete` statuses
   - If scene status > `shot_list_ready` → return 400 "Cannot unlock: frames already generated"
4. Update scene: `shot_list_locked_at = NULL`, `status = 'draft'`
5. Optional: Log unlock event to audit table (future enhancement)

---

### **Task 5: Frontend Validation Logic**
**Purpose**: Client-side validation before lock attempt

**File**: `src/components/pipeline/Stage7ShotList.tsx`

**Changes**:
1. **Add State**:
```typescript
const [validationErrors, setValidationErrors] = useState<ValidationError[]>([]);
const [validationWarnings, setValidationWarnings] = useState<ValidationWarning[]>([]);
const [showValidationModal, setShowValidationModal] = useState(false);
const [isLocking, setIsLocking] = useState(false);
```

2. **Add Validation Function** (client-side preview):
```typescript
const validateShotsLocally = (): { errors: ValidationError[], warnings: ValidationWarning[] } => {
  const errors: ValidationError[] = [];
  const warnings: ValidationWarning[] = [];
  
  shots.forEach((shot, index) => {
    // Required fields
    if (!shot.action?.trim()) {
      errors.push({ shotId: shot.shotId, shotOrder: index, field: 'action', message: 'Action is required', severity: 'error' });
    }
    if (!shot.setting?.trim()) {
      errors.push({ shotId: shot.shotId, shotOrder: index, field: 'setting', message: 'Setting is required', severity: 'error' });
    }
    if (!shot.camera?.trim()) {
      errors.push({ shotId: shot.shotId, shotOrder: index, field: 'camera', message: 'Camera is required', severity: 'error' });
    }
    
    // Duration validation
    if (shot.duration < 1 || shot.duration > 30) {
      errors.push({ shotId: shot.shotId, shotOrder: index, field: 'duration', message: 'Duration must be 1-30 seconds', severity: 'error' });
    } else if (shot.duration < 4 || shot.duration > 12) {
      warnings.push({ shotId: shot.shotId, shotOrder: index, field: 'duration', message: `Duration ${shot.duration}s is unusual (typical: 6-10s)`, severity: 'warning' });
    }
  });
  
  // Total duration check
  const totalDuration = shots.reduce((sum, s) => sum + s.duration, 0);
  if (totalDuration < 10) {
    warnings.push({ shotId: 'scene', shotOrder: -1, field: 'total_duration', message: `Scene is very short (${totalDuration}s)`, severity: 'warning' });
  } else if (totalDuration > 120) {
    warnings.push({ shotId: 'scene', shotOrder: -1, field: 'total_duration', message: `Scene is very long (${totalDuration}s)`, severity: 'warning' });
  }
  
  return { errors, warnings };
};
```

3. **Modify "Lock Shot List & Proceed" Button Handler**:
```typescript
const handleLockShotList = async () => {
  // Wait for pending saves
  if (pendingUpdates.size > 0) {
    toast({
      title: 'Saving changes...',
      description: 'Please wait for auto-save to complete',
    });
    return;
  }
  
  // Local validation preview
  const { errors, warnings } = validateShotsLocally();
  setValidationErrors(errors);
  setValidationWarnings(warnings);
  
  if (errors.length > 0 || warnings.length > 0) {
    setShowValidationModal(true);
    return;
  }
  
  // No issues, proceed to lock
  await lockShotList(false);
};

const lockShotList = async (force: boolean) => {
  try {
    setIsLocking(true);
    
    const response = await shotService.lockShotList(projectId, sceneId, force);
    
    toast({
      title: 'Shot list locked',
      description: `Scene ${response.scene.sceneNumber} is ready for asset assignment`,
    });
    
    setShowValidationModal(false);
    onComplete(); // Proceed to next stage
  } catch (error: any) {
    if (error.status === 409) {
      // Server returned warnings - show modal
      setValidationWarnings(error.data.warnings);
      setShowValidationModal(true);
    } else if (error.status === 400) {
      // Server validation errors
      setValidationErrors(error.data.errors);
      setShowValidationModal(true);
      toast({
        title: 'Validation failed',
        description: `${error.data.errors.length} issues must be fixed`,
        variant: 'destructive',
      });
    } else {
      toast({
        title: 'Failed to lock shot list',
        description: error.message,
        variant: 'destructive',
      });
    }
  } finally {
    setIsLocking(false);
  }
};
```

4. **Update Button UI** (line ~749):
```typescript
<Button 
  variant="default" 
  onClick={handleLockShotList}
  disabled={isSaving || shots.length === 0 || isLocking}
  className="bg-primary hover:bg-primary/90 text-primary-foreground"
>
  {isLocking ? (
    <>
      <Loader2 className="w-4 h-4 mr-2 animate-spin" />
      Locking...
    </>
  ) : (
    <>
      <Check className="w-4 h-4 mr-2" />
      Lock Shot List & Proceed
    </>
  )}
</Button>
```

---

### **Task 6: Validation Warning Modal**
**Purpose**: Display validation errors/warnings with option to force lock or fix issues

**File**: `src/components/pipeline/Stage7ShotList.tsx`

**Component**: New Dialog at end of component (similar to split dialog)

**Features**:
1. Show errors in red with icons
2. Show warnings in yellow with icons
3. List each issue with shot ID and field
4. Click issue to jump to that shot (set as selectedShot)
5. Buttons:
   - "Fix Issues" (if errors) → close modal, stay on page
   - "Go Back" (if warnings) → close modal
   - "Lock Anyway" (if only warnings, no errors) → `lockShotList(true)`

**UI Structure**:
```tsx
<Dialog open={showValidationModal} onOpenChange={setShowValidationModal}>
  <DialogContent className="sm:max-w-2xl">
    <DialogHeader>
      <DialogTitle className="flex items-center gap-2">
        <AlertTriangle className="w-5 h-5 text-yellow-500" />
        Shot List Validation
      </DialogTitle>
      <DialogDescription>
        {validationErrors.length > 0 
          ? 'Please fix the following issues before locking:'
          : 'The following warnings were found. You can fix them or proceed anyway.'}
      </DialogDescription>
    </DialogHeader>
    
    <ScrollArea className="max-h-96">
      <div className="space-y-4">
        {/* Errors Section */}
        {validationErrors.length > 0 && (
          <div>
            <h4 className="text-sm font-medium text-destructive mb-2 flex items-center gap-2">
              <AlertCircle className="w-4 h-4" />
              Errors ({validationErrors.length})
            </h4>
            <div className="space-y-2">
              {validationErrors.map((error, i) => (
                <button
                  key={i}
                  onClick={() => {
                    const shot = shots.find(s => s.shotId === error.shotId);
                    if (shot) setSelectedShot(shot);
                    setShowValidationModal(false);
                  }}
                  className="w-full text-left p-3 rounded-md bg-destructive/10 border border-destructive/30 hover:bg-destructive/20 transition-colors"
                >
                  <div className="flex items-start gap-2">
                    <Badge variant="destructive" className="font-mono text-xs">
                      {error.shotId}
                    </Badge>
                    <span className="text-sm text-foreground">{error.message}</span>
                  </div>
                </button>
              ))}
            </div>
          </div>
        )}
        
        {/* Warnings Section */}
        {validationWarnings.length > 0 && (
          <div>
            <h4 className="text-sm font-medium text-yellow-600 dark:text-yellow-500 mb-2 flex items-center gap-2">
              <AlertTriangle className="w-4 h-4" />
              Warnings ({validationWarnings.length})
            </h4>
            <div className="space-y-2">
              {validationWarnings.map((warning, i) => (
                <button
                  key={i}
                  onClick={() => {
                    if (warning.shotId !== 'scene') {
                      const shot = shots.find(s => s.shotId === warning.shotId);
                      if (shot) setSelectedShot(shot);
                    }
                    setShowValidationModal(false);
                  }}
                  className="w-full text-left p-3 rounded-md bg-yellow-500/10 border border-yellow-500/30 hover:bg-yellow-500/20 transition-colors"
                >
                  <div className="flex items-start gap-2">
                    <Badge variant="outline" className="font-mono text-xs border-yellow-500/50">
                      {warning.shotId}
                    </Badge>
                    <span className="text-sm text-foreground">{warning.message}</span>
                  </div>
                </button>
              ))}
            </div>
          </div>
        )}
      </div>
    </ScrollArea>
    
    <DialogFooter className="flex-row gap-2 sm:gap-2">
      <Button
        variant="ghost"
        onClick={() => setShowValidationModal(false)}
      >
        {validationErrors.length > 0 ? 'Fix Issues' : 'Go Back'}
      </Button>
      
      {validationErrors.length === 0 && validationWarnings.length > 0 && (
        <Button
          onClick={() => lockShotList(true)}
          disabled={isLocking}
          className="bg-primary hover:bg-primary/90"
        >
          {isLocking ? (
            <>
              <Loader2 className="w-4 h-4 mr-2 animate-spin" />
              Locking...
            </>
          ) : (
            <>
              <Check className="w-4 h-4 mr-2" />
              Lock Anyway
            </>
          )}
        </Button>
      )}
    </DialogFooter>
  </DialogContent>
</Dialog>
```

---

### **Task 7: Frontend Shot Service Updates**
**Purpose**: Add API methods for locking/unlocking

**File**: `src/lib/services/shotService.ts`

**New Methods**:

```typescript
async lockShotList(
  projectId: string, 
  sceneId: string, 
  force: boolean = false
): Promise<{ success: boolean; scene: any }> {
  const session = await supabase.auth.getSession();
  const token = session.data.session?.access_token;
  
  const response = await fetch(
    `${API_BASE_URL}/api/projects/${projectId}/scenes/${sceneId}/shots/lock`,
    {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({ force })
    }
  );
  
  const data = await response.json();
  
  if (!response.ok) {
    const error: any = new Error(data.error || 'Failed to lock shot list');
    error.status = response.status;
    error.data = data;
    throw error;
  }
  
  return data;
}

async unlockShotList(
  projectId: string, 
  sceneId: string, 
  reason?: string
): Promise<{ success: boolean }> {
  const session = await supabase.auth.getSession();
  const token = session.data.session?.access_token;
  
  const response = await fetch(
    `${API_BASE_URL}/api/projects/${projectId}/scenes/${sceneId}/shots/unlock`,
    {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({ reason })
    }
  );
  
  const data = await response.json();
  
  if (!response.ok) {
    throw new Error(data.error || 'Failed to unlock shot list');
  }
  
  return data;
}
```

---

### **Task 8: Visual Indicators for Locked Shots**
**Purpose**: Show read-only state when shot list is locked

**File**: `src/components/pipeline/Stage7ShotList.tsx`

**Changes**:
1. **Fetch scene lock status**:
```typescript
const [isSceneLocked, setIsSceneLocked] = useState(false);

useEffect(() => {
  const checkLockStatus = async () => {
    const scenes = await sceneService.fetchScenes(projectId);
    const currentScene = scenes.find(s => s.id === sceneId);
    setIsSceneLocked(!!currentScene?.shotListLockedAt);
  };
  checkLockStatus();
}, [projectId, sceneId]);
```

2. **Disable editing when locked**:
   - Disable all input fields: `disabled={isSceneLocked || isSaving}`
   - Disable split/merge/delete buttons: `disabled={isSceneLocked || ...}`
   - Show lock banner at top of inspector
   - Change button text to "Shot List Locked" with lock icon

3. **Lock Banner Component**:
```tsx
{isSceneLocked && (
  <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-3 mb-4">
    <div className="flex items-center gap-2">
      <Lock className="w-4 h-4 text-blue-500" />
      <div>
        <p className="text-sm font-medium text-blue-500">Shot List Locked</p>
        <p className="text-xs text-muted-foreground">
          This shot list has been approved. Unlock to make changes.
        </p>
      </div>
      <Button
        variant="outline"
        size="sm"
        onClick={handleUnlock}
        className="ml-auto"
      >
        Unlock
      </Button>
    </div>
  </div>
)}
```

---

### **Task 9: Scene Type Updates**
**Purpose**: Add lock timestamp to Scene interface

**File**: `src/types/scene.ts`

**Changes**:
```typescript
export interface Scene {
  // ... existing fields ...
  shotListLockedAt?: string; // ISO timestamp when shot list was locked
}
```

**File**: `src/lib/services/sceneService.ts`

**Changes**: Update scene transformation to include `shotListLockedAt`:
```typescript
shotListLockedAt: scene.shot_list_locked_at || (scene as any).shotListLockedAt
```

---

### **Task 10: Backend Scene Fetch Updates**
**Purpose**: Return lock status in scene queries

**File**: `backend/src/routes/projects.ts`

**Changes**: Add `shot_list_locked_at` to scene SELECT queries (lines ~460, ~584):
```typescript
.select('id, scene_number, slug, status, script_excerpt, end_state_summary, end_frame_thumbnail_url, updated_at, expected_characters, expected_location, expected_props, dependencies_extracted_at, shot_list_locked_at')
```

---

### **Task 11: Testing & Documentation**

**Manual Testing Checklist**:
- [ ] Lock shot list with valid shots → success
- [ ] Lock shot list with missing required fields → error modal
- [ ] Lock shot list with warnings → warning modal, can force
- [ ] Unlock shot list → editable again
- [ ] Try to edit locked shot list → fields disabled
- [ ] Navigate away and back → lock status persists
- [ ] Check scene status updates to `shot_list_ready`

**Unit Tests** (optional but recommended):
- `backend/src/tests/shotValidation.test.ts` - Test validation logic
- Test required field validation
- Test duration limits
- Test coherence checks

**Documentation Updates**:
- Update `Phase-4-Status-Implementations.md` with Feature 4.5 completion
- Add validation rules to `._docs/architecture-and-rules.md`
- Update user flow documentation

---

## Implementation Order

**Recommended sequence**:

1. **Day 1: Database & Backend Foundation**
   - Task 1: Database migration
   - Task 2: Validation service
   - Task 3: Lock endpoint
   - Task 4: Unlock endpoint (optional)

2. **Day 2: Frontend Integration**
   - Task 7: Shot service methods
   - Task 5: Validation logic
   - Task 6: Warning modal

3. **Day 3: Polish & Testing**
   - Task 8: Visual indicators
   - Task 9: Type updates
   - Task 10: Backend updates
   - Task 11: Testing & docs

---

## Open Questions for You

Before I start implementing, I'd like your input on:

1. **Warnings vs Errors**: Should unusual duration (e.g., 2 seconds) be a hard error or just a warning that can be bypassed?

2. **Unlock Restrictions**: Should unlocking be allowed if frames have already been generated in Stage 10? Or should it always be allowed with a warning?

3. **Shot Coherence**: Beyond required fields and duration, are there other coherence checks you want? For example:
   - Should we validate that characters mentioned in shots exist in scene dependencies?
   - Should we check for logical continuity between shots?

4. **Validation Scope**: Should validation happen only at lock time, or should we show real-time validation indicators (red borders on required fields)?

5. **Force Lock**: Should force lock bypass all warnings, or should some warnings be un-bypassable?

Let me know your preferences, and I'll proceed with implementation!