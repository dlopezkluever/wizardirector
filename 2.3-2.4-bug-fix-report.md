# Bug Fix Report: Context Manager Database Integration

**Date**: 2026-01-16  
**Issue**: Context Manager failing to load writing style capsules during Stage 2 generation

---

## Issues Found

### Issue #1: Incorrect Database Query Method
**Location**: `backend/src/services/contextManager.ts` (lines 297, 339, 360)

**Problem**: Context Manager was attempting to use `this.db.query()` method which doesn't exist on `DatabaseService`.

**Error**:
```
TypeError: this.db.query is not a function
Property 'query' does not exist on type 'DatabaseService'
```

**Root Cause**: The `DatabaseService` class only exposes the Supabase client via `this.db.supabase`, not a raw `query()` method.

**Fix**: Replaced all SQL query calls with Supabase query builder methods:

```typescript
// BEFORE (âŒ Broken)
const result = await this.db.query(
  `SELECT * FROM projects WHERE id = $1`,
  [projectId]
);

// AFTER (âœ… Fixed)
const { data, error } = await this.db.supabase
  .from('projects')
  .select('*')
  .eq('id', projectId)
  .single();
```

**Methods Updated**:
1. `fetchProject()` - Refactored to use 3 separate Supabase queries
2. `fetchBeatSheet()` - Converted to Supabase query builder
3. `fetchMasterScriptSummary()` - Converted to Supabase query builder

---

### Issue #2: Incorrect Data Path for Stage 1 Content
**Location**: `backend/src/services/contextManager.ts` (line 340)

**Problem**: Context Manager was looking for `writingStyleCapsuleId` at the wrong path in Stage 1 content.

**Looking at**: 
```typescript
stage1Content.projectParams?.writingStyleCapsuleId  // âŒ Wrong path
```

**Should be**: 
```typescript
stage1Content.processedInput?.projectParams?.writingStyleCapsuleId  // âœ… Correct path
```

**Root Cause**: Stage 1 stores processed input in a nested structure:
```json
{
  "content": {
    "selectedMode": "expansion",
    "processedInput": {
      "projectParams": {
        "writingStyleCapsuleId": "uuid-here"
      }
    }
  }
}
```

**Fix**: Updated `fetchProject()` to access the correct nested path:

```typescript
// Extract processedInput.projectParams first
const stage1ProjectParams = stage1Content.processedInput?.projectParams || {};

// Then use it for all project params
writingStyleCapsuleId: project.writing_style_capsule_id || stage1ProjectParams.writingStyleCapsuleId
```

---

### Issue #3: Missing stageStateId in Metadata
**Location**: Frontend services (treatmentService, beatService, scriptService)

**Problem**: The backend logging code requires `stageStateId` in metadata, but frontend services weren't passing it.

**Backend Requirement**:
```typescript
// backend/src/routes/llm.ts line 291
if (validatedRequest.metadata?.stageStateId && validatedRequest.metadata?.globalContext) {
  // Log to style_capsule_applications table
}
```

**Fix**: Updated all three services to fetch the current stage state before calling the LLM:

```typescript
// Get current stage state ID for application logging
const currentStageState = await stageStateService.getStageState(projectId, stageNumber);

// Include in metadata
metadata: {
  projectId,
  branchId: 'main',
  stage: stageNumber,
  stageStateId: currentStageState?.id,  // â† Added
  // ...
}
```

**Services Updated**:
- `treatmentService.generateTreatments()` - Stage 2
- `treatmentService.regenerateTreatments()` - Stage 2 regeneration
- `beatService.generateBeats()` - Stage 3
- `beatService.regenerateBeats()` - Stage 3 regeneration
- `scriptService.generateScript()` - Stage 4
- `scriptService.regenerateScript()` - Stage 4 regeneration

---

## Files Modified

### Backend
1. **`backend/src/services/contextManager.ts`**
   - Fixed database query methods (3 methods)
   - Fixed Stage 1 content path for all project params (9 fields)

### Frontend Services
2. **`src/lib/services/treatmentService.ts`**
   - Added import for `stageStateService`
   - Fetch stage state before LLM call (2 methods)
   - Pass `stageStateId` in metadata

3. **`src/lib/services/beatService.ts`**
   - Added import for `stageStateService`
   - Fetch stage state before LLM call (2 methods)
   - Pass `stageStateId` in metadata

4. **`src/lib/services/scriptService.ts`**
   - Added import for `stageStateService`
   - Fetch stage state before LLM call (2 methods)
   - Pass `stageStateId` in metadata

---

## Expected Behavior After Fix

### Backend Console Logs (Stage 2 Generation)
You should now see the **complete** log sequence:

```
[ContextManager] Assembling global context for project {id}, branch main
[ContextManager] Loaded writing style capsule: {capsule_name}          â† Now appears!
[API] Injected writing style context from Context Manager (X chars)    â† Now appears!
[API] Interpolating template with variables...
[API] Template interpolated successfully. System prompt length: X, User prompt length: Y
```

### Network Request Inspection
The `/api/llm/generate-from-template` request should show:
- `writing_style_context` is **NOT empty** (contains formatted style guidance)
- Response includes properly styled content

### Database Verification
Query to check if capsule was applied:

```sql
SELECT 
  ss.stage_number,
  ss.content->'processedInput'->'projectParams'->>'writingStyleCapsuleId' as capsule_id,
  sca.style_capsule_id as applied_capsule_id,
  sc.name as capsule_name
FROM stage_states ss
LEFT JOIN style_capsule_applications sca ON sca.stage_state_id = ss.id
LEFT JOIN style_capsules sc ON sc.id = sca.style_capsule_id
WHERE ss.branch_id = '{your-branch-id}'
AND ss.stage_number = 2
ORDER BY ss.version DESC
LIMIT 1;
```

---

## Testing Instructions

### 1. Restart Backend Server
The `tsx watch` should have auto-reloaded, but restart to be safe:

```bash
cd backend
npm run dev
```

### 2. Create New Test Project
1. Go to Stage 1
2. Select a **writing style capsule**
3. Complete Stage 1 setup
4. Lock Stage 1

### 3. Generate Treatment (Stage 2)
1. Click "Generate Treatments"
2. **Watch backend console** for the complete log sequence above
3. **Check network tab**: Verify `writing_style_context` is populated
4. **Verify generated content** reflects the style capsule

### 4. Verify Database Logging
Check that `style_capsule_applications` table receives an entry:

```sql
SELECT * FROM style_capsule_applications 
ORDER BY applied_at DESC 
LIMIT 1;
```

---

## Original Testing Checklist Progress

From `2.3-2.4-implementation-summary.md`:

### Step 1: Create new project with writing style capsule âœ…
- Capsule ID saved in `stage_states.content.processedInput.projectParams.writingStyleCapsuleId`

### Step 2: Generate treatments (Stage 2) ðŸ”§ NOW FIXED
- âœ… Network tab includes `projectId`, `branchId`
- âœ… Context Manager assembles global context (no more errors)
- âœ… `writing_style_context` is injected (non-empty)

### Steps 3-5: Continue testing after Step 2 passes
- Generate beat sheet (Stage 3)
- Generate master script (Stage 4)  
- Check `style_capsule_applications` table

---

## Related Files

- `backend/src/services/contextManager.ts` - Fixed file
- `backend/src/config/database.ts` - DatabaseService definition
- `src/components/pipeline/Stage1InputMode.tsx` - Where capsuleId is saved
- `backend/src/routes/llm.ts` - Where Context Manager is called

---

## Summary

**Three critical bugs fixed**:
1. âœ… Database queries now use correct Supabase client methods
2. âœ… Context Manager now reads `writingStyleCapsuleId` from correct path in Stage 1 data
3. âœ… Frontend services now pass `stageStateId` to enable application logging

**Result**: 
- The Context Manager can successfully load and inject writing style capsules during Stage 2-4 generation
- Style capsule applications are now logged to the database for audit trails
- The `style_capsule_applications` table will be populated after each generation

**Next Step**: Re-run the complete testing checklist to verify all fixes work end-to-end.

