# Feature 4.5: Shot List Validation & Locking - Implementation Plan v1

## Executive Summary

This plan implements a robust gatekeeper that validates shot list completeness and locks the shot list before allowing users to proceed from Stage 7 (Shot List) to Stage 8 (Asset Assignment). This is a **critical architectural boundary** between narrative design (Phase A) and production execution (Phase B).

**Status**: ✅ **PRODUCTION-READY** (Incorporates comprehensive AI analysis recommendations)

**Key Improvements Over v0**:
- ⚠️ **Fixed critical auto-save race condition** that could cause validation against stale data
- ⚠️ **Added explicit scene status transitions** to enable downstream Stage 8+ access
- ⚠️ **Redesigned unlock endpoint** to follow deterministic invalidation architecture
- ✅ **Enhanced validation** with character name validation, minimum shot count, and ID uniqueness checks
- ✅ **Added forced lock audit trail** for debugging and transparency
- ✅ **Implemented hybrid validation UX** with real-time indicators and gate validation

**Estimated Implementation Time**: 9-13 hours  
**Priority**: High (blocks entire Phase B pipeline)

Based on codebase analysis and comprehensive AI review, this plan addresses all critical flaws and design gaps identified in the analysis phase.

---

## Overview

**Goal**: Implement a robust gatekeeper that validates shot list completeness, enforces quality standards, and locks the shot list before allowing users to proceed to Stage 8 (Asset Assignment). This is a **critical architectural boundary** between narrative design (Phase A) and production execution (Phase B).

**Pattern to Follow**: Stage 5 Assets validation/locking (lines 364-397 in `Stage5Assets.tsx`) serves as the architectural template.

**Key Files to Modify**:
- Frontend: `src/components/pipeline/Stage7ShotList.tsx`
- Backend: `backend/src/routes/projects.ts` (new endpoints)
- Backend: `backend/src/services/shotValidationService.ts` (NEW)
- Database: New migration for `shot_list_locked_at` field + `shot_list_ready` status
- Types: `src/types/scene.ts`

**Critical Success Factors**:
1. ✅ **Auto-save synchronization** - Must handle race condition between debounced saves and lock attempt
2. ✅ **Scene status transitions** - Must explicitly update scene.status to enable downstream stages
3. ✅ **Data integrity** - Validation must prevent corrupted shot data from entering Phase B

---

## Task Breakdown

### **Task 1: Database Schema Migration** ⚠️ CRITICAL FIX APPLIED
**Purpose**: Add fields to track shot list locking + ensure `shot_list_ready` status exists

**File**: `backend/migrations/014_add_shot_list_locking.sql`

**Changes**:
1. Add `shot_list_locked_at` column to `scenes` table (TIMESTAMPTZ, nullable)
2. **CRITICAL**: Update scene status CHECK constraint to include `'shot_list_ready'` value
3. Add partial index on `shot_list_locked_at` for queries filtering locked scenes
4. Include rollback SQL in comments

**Complete Migration**:
```sql
-- Migration 014: Add shot list locking to scenes table
-- Purpose: Enable Stage 7 shot list validation and gatekeeper functionality
-- CRITICAL: This migration adds 'shot_list_ready' status to enable downstream Stage 8

BEGIN;

-- Add shot list locking timestamp
ALTER TABLE scenes ADD COLUMN shot_list_locked_at TIMESTAMPTZ;

COMMENT ON COLUMN scenes.shot_list_locked_at IS 
  'Timestamp when shot list was validated and locked at Stage 7. 
   NULL means shot list is still editable. Non-NULL sets status to shot_list_ready.';

-- Create partial index for performance (only index locked scenes)
CREATE INDEX idx_scenes_shot_list_locked ON scenes(shot_list_locked_at) 
  WHERE shot_list_locked_at IS NOT NULL;

-- CRITICAL: Ensure 'shot_list_ready' is a valid scene status
-- (This updates the CHECK constraint from migration 003)

ALTER TABLE scenes 
  DROP CONSTRAINT IF EXISTS scenes_status_check;

ALTER TABLE scenes 
  ADD CONSTRAINT scenes_status_check 
  CHECK (status IN (
    'draft',
    'shot_list_ready',      -- NEW: Status after Stage 7 lock
    'frames_locked', 
    'video_complete', 
    'outdated', 
    'continuity_broken'
  ));

COMMIT;

-- Rollback instructions:
-- BEGIN;
-- ALTER TABLE scenes DROP COLUMN shot_list_locked_at;
-- DROP INDEX IF EXISTS idx_scenes_shot_list_locked;
-- ALTER TABLE scenes DROP CONSTRAINT scenes_status_check;
-- ALTER TABLE scenes ADD CONSTRAINT scenes_status_check 
--   CHECK (status IN ('draft', 'frames_locked', 'video_complete', 'outdated', 'continuity_broken'));
-- COMMIT;
```

**Why This Fix Is Critical**:
- Without `shot_list_ready` in the status enum, the lock endpoint will fail with a constraint violation
- Stage 8 (Asset Assignment) checks for `status = 'shot_list_ready'` before allowing entry
- Stage 6 Script Hub uses scene status to render UI indicators

---

### **Task 2: Backend Validation Service** ⚠️ ENHANCED WITH CRITICAL VALIDATIONS
**Purpose**: Create reusable shot validation logic

**File**: `backend/src/services/shotValidationService.ts` (NEW)

**Features**:

1. **Critical Pre-Validation** (MUST PASS):
   - ✅ **Minimum Shot Count**: Error if `shots.length === 0` (no empty scenes)
   - ✅ **Shot ID Uniqueness**: Error if duplicate shot IDs exist

2. **Field Validation**:
   - Required fields: `action`, `setting`, `camera` (non-empty strings after trim)
   - **Duration Rules**:
     - **Hard Error**: < 1s or > 30s (API limits)
     - **Warning**: < 4s or > 12s (unusual but valid creative choices)
   - Optional fields: `dialogue`, `charactersForeground`, `charactersBackground`, `continuityFlags`

3. **Shot Coherence Checking**:
   - All shots have sequential `shot_order` (0, 1, 2, ...)
   - ✅ **Character Name Validation** (NEW): Warn if character names don't match `scene.expected_characters`
   - Total duration bounds (dynamic based on shot count):
     - Warning if `< shots.length * 4` or `> shots.length * 15` seconds

4. **Validation Result Structure**:
```typescript
interface ValidationResult {
  valid: boolean;
  errors: ValidationError[];
  warnings: ValidationWarning[];
}

interface ValidationError {
  shotId: string;
  shotOrder: number;
  field: string;
  message: string;
  severity: 'error' | 'warning';
}
```

5. **Complete Validation Implementation**:

```typescript
import type { Shot } from '@/types/scene';

export interface ValidationResult {
  valid: boolean;
  errors: ValidationError[];
  warnings: ValidationWarning[];
}

export interface ValidationError {
  shotId: string;
  shotOrder: number;
  field: string;
  message: string;
  severity: 'error' | 'warning';
}

export type ValidationWarning = ValidationError;

export class ShotValidationService {
  validateShots(shots: Shot[], sceneData?: { expected_characters?: string[] }): ValidationResult {
    const errors: ValidationError[] = [];
    const warnings: ValidationWarning[] = [];

    // CRITICAL: Check for empty shot list
    if (shots.length === 0) {
      errors.push({
        shotId: 'scene',
        shotOrder: -1,
        field: 'shot_count',
        message: 'Scene must have at least one shot. Use Stage 7 to generate a shot list.',
        severity: 'error'
      });
      return { valid: false, errors, warnings };
    }

    // CRITICAL: Check for duplicate shot IDs
    const shotIdCounts = new Map<string, number>();
    shots.forEach(shot => {
      const count = shotIdCounts.get(shot.shotId) || 0;
      shotIdCounts.set(shot.shotId, count + 1);
    });

    shotIdCounts.forEach((count, shotId) => {
      if (count > 1) {
        errors.push({
          shotId,
          shotOrder: -1,
          field: 'shotId',
          message: `Duplicate shot ID "${shotId}" found ${count} times. Each shot must have a unique ID.`,
          severity: 'error'
        });
      }
    });

    // Field validation for each shot
    shots.forEach((shot, index) => {
      // Required fields
      if (!shot.action?.trim()) {
        errors.push({
          shotId: shot.shotId,
          shotOrder: index,
          field: 'action',
          message: 'Action is required',
          severity: 'error'
        });
      }
      if (!shot.setting?.trim()) {
        errors.push({
          shotId: shot.shotId,
          shotOrder: index,
          field: 'setting',
          message: 'Setting is required',
          severity: 'error'
        });
      }
      if (!shot.camera?.trim()) {
        errors.push({
          shotId: shot.shotId,
          shotOrder: index,
          field: 'camera',
          message: 'Camera is required',
          severity: 'error'
        });
      }

      // Duration validation
      if (shot.duration < 1) {
        errors.push({
          shotId: shot.shotId,
          shotOrder: index,
          field: 'duration',
          message: 'Minimum duration is 1 second (API limit)',
          severity: 'error'
        });
      } else if (shot.duration > 30) {
        errors.push({
          shotId: shot.shotId,
          shotOrder: index,
          field: 'duration',
          message: 'Maximum duration is 30 seconds (quality threshold)',
          severity: 'error'
        });
      } else if (shot.duration < 4) {
        warnings.push({
          shotId: shot.shotId,
          shotOrder: index,
          field: 'duration',
          message: `Duration ${shot.duration}s is very short. Quick cuts work for action but may feel rushed for dialogue.`,
          severity: 'warning'
        });
      } else if (shot.duration > 12) {
        warnings.push({
          shotId: shot.shotId,
          shotOrder: index,
          field: 'duration',
          message: `Duration ${shot.duration}s is unusually long. Long takes can be powerful but risk viewer attention.`,
          severity: 'warning'
        });
      }

      // Character name validation (if scene data provided)
      if (sceneData?.expected_characters) {
        const expectedCharacters = sceneData.expected_characters.map(c => c.toLowerCase().trim());
        
        (shot.charactersForeground || []).forEach(charName => {
          const normalized = charName.toLowerCase().trim();
          if (!expectedCharacters.includes(normalized)) {
            // Find closest match for typo suggestion
            const closestMatch = this.findClosestMatch(normalized, expectedCharacters);
            warnings.push({
              shotId: shot.shotId,
              shotOrder: index,
              field: 'charactersForeground',
              message: closestMatch
                ? `Character "${charName}" not found in scene dependencies. Did you mean "${closestMatch}"?`
                : `Character "${charName}" not found in scene dependencies. This may cause issues in Stage 8.`,
              severity: 'warning'
            });
          }
        });
      }
    });

    // Total duration check (dynamic bounds based on shot count)
    const totalDuration = shots.reduce((sum, s) => sum + s.duration, 0);
    const expectedMin = shots.length * 4;  // 4s/shot minimum
    const expectedMax = shots.length * 15; // 15s/shot maximum

    if (totalDuration < expectedMin) {
      warnings.push({
        shotId: 'scene',
        shotOrder: -1,
        field: 'total_duration',
        message: `Scene duration (${totalDuration}s) is unusually short for ${shots.length} shots. Expected at least ${expectedMin}s.`,
        severity: 'warning'
      });
    } else if (totalDuration > expectedMax) {
      warnings.push({
        shotId: 'scene',
        shotOrder: -1,
        field: 'total_duration',
        message: `Scene duration (${totalDuration}s) is very long for ${shots.length} shots. Expected no more than ${expectedMax}s. Consider splitting the scene.`,
        severity: 'warning'
      });
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings
    };
  }

  // Simple Levenshtein distance for typo detection
  private findClosestMatch(input: string, candidates: string[]): string | null {
    if (candidates.length === 0) return null;

    let closest = candidates[0];
    let minDistance = this.levenshteinDistance(input, candidates[0]);

    candidates.forEach(candidate => {
      const distance = this.levenshteinDistance(input, candidate);
      if (distance < minDistance) {
        minDistance = distance;
        closest = candidate;
      }
    });

    // Only suggest if distance is < 3 (reasonable typo)
    return minDistance < 3 ? closest : null;
  }

  private levenshteinDistance(a: string, b: string): number {
    const matrix: number[][] = [];

    for (let i = 0; i <= b.length; i++) {
      matrix[i] = [i];
    }

    for (let j = 0; j <= a.length; j++) {
      matrix[0][j] = j;
    }

    for (let i = 1; i <= b.length; i++) {
      for (let j = 1; j <= a.length; j++) {
        if (b.charAt(i - 1) === a.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          );
        }
      }
    }

    return matrix[b.length][a.length];
  }
}

export const shotValidationService = new ShotValidationService();
```

6. **Export**:
   - `ShotValidationService` class
   - `shotValidationService` singleton
   - `ValidationResult`, `ValidationError` interfaces

**Example Validation Messages**:
- Error: `"Scene must have at least one shot"`
- Error: `"Duplicate shot ID '3A' found 2 times"`
- Error: `"Shot 3A: 'action' is required"`
- Error: `"Shot 3B: Minimum duration is 1 second (API limit)"`
- Warning: `"Shot 3C: Duration 2s is very short. Quick cuts work for action but may feel rushed for dialogue."`
- Warning: `"Character 'Jhon Doe' not found in scene dependencies. Did you mean 'John Doe'?"`

---

### **Task 3: Backend Locking Endpoint** ⚠️ CRITICAL FIXES APPLIED
**Purpose**: Validate and lock shot list, update scene status, audit forced locks

**File**: `backend/src/routes/projects.ts`

**New Endpoint**: `POST /api/projects/:id/scenes/:sceneId/shots/lock`

**Request Body**:
```typescript
{
  force?: boolean; // Skip warnings (not errors) if true
}
```

**Complete Implementation**:

```typescript
// POST /api/projects/:id/scenes/:sceneId/shots/lock
router.post('/:id/scenes/:sceneId/shots/lock', async (req, res) => {
  try {
    const { id: projectId, sceneId } = req.params;
    const { force = false } = req.body;
    const userId = req.user!.id;

    // 1. Verify ownership
    const { data: project, error: projectError } = await supabase
      .from('projects')
      .select('id, active_branch_id')
      .eq('id', projectId)
      .eq('user_id', userId)
      .single();

    if (projectError || !project) {
      return res.status(404).json({ error: 'Project not found' });
    }

    // 2. Fetch scene (verify it belongs to active branch)
    const { data: scene, error: sceneError } = await supabase
      .from('scenes')
      .select('id, scene_number, status, shot_list_locked_at, expected_characters')
      .eq('id', sceneId)
      .eq('branch_id', project.active_branch_id)
      .single();

    if (sceneError || !scene) {
      return res.status(404).json({ error: 'Scene not found' });
    }

    // 3. Check if already locked (idempotent)
    if (scene.shot_list_locked_at) {
      // Already locked - return success
      return res.json({
        success: true,
        scene: {
          id: scene.id,
          status: scene.status,
          shotListLockedAt: scene.shot_list_locked_at,
          sceneNumber: scene.scene_number
        }
      });
    }

    // 4. Fetch all shots for validation
    const { data: shots, error: shotsError } = await supabase
      .from('shots')
      .select('*')
      .eq('scene_id', sceneId)
      .order('shot_order', { ascending: true });

    if (shotsError) {
      return res.status(500).json({ error: 'Failed to fetch shots' });
    }

    // 5. Validate shots
    const validationResult = shotValidationService.validateShots(
      shots || [], 
      { expected_characters: scene.expected_characters }
    );

    // 6. Handle validation results
    if (validationResult.errors.length > 0) {
      // ERRORS: Cannot proceed, even with force
      return res.status(400).json({
        error: 'Shot list validation failed',
        errors: validationResult.errors,
        canForce: false
      });
    }

    if (validationResult.warnings.length > 0 && !force) {
      // WARNINGS: Can bypass with force=true
      return res.status(409).json({
        error: 'Shot list has warnings',
        warnings: validationResult.warnings,
        canForce: true
      });
    }

    // 7. Lock the shot list
    const updateData: any = {
      shot_list_locked_at: new Date().toISOString(),
      status: 'shot_list_ready',  // CRITICAL: Explicit status transition
      updated_at: new Date().toISOString()
    };

    // Store forced lock metadata for audit trail
    if (force && validationResult.warnings.length > 0) {
      updateData.metadata = {
        ...(scene.metadata || {}),
        forcedLock: true,
        forcedLockWarnings: validationResult.warnings.map(w => w.message),
        forcedLockAt: new Date().toISOString(),
        forcedLockBy: userId
      };
    }

    const { data: updatedScene, error: updateError } = await supabase
      .from('scenes')
      .update(updateData)
      .eq('id', sceneId)
      .eq('branch_id', project.active_branch_id)
      .is('shot_list_locked_at', null)  // Prevent race condition
      .select('*')
      .single();

    if (updateError || !updatedScene) {
      console.error('Failed to lock scene:', updateError);
      return res.status(500).json({ error: 'Failed to lock shot list' });
    }

    // 8. Return success
    res.json({
      success: true,
      scene: {
        id: updatedScene.id,
        status: updatedScene.status,
        shotListLockedAt: updatedScene.shot_list_locked_at,
        sceneNumber: updatedScene.scene_number,
        shotCount: shots?.length || 0,
        forcedLock: force && validationResult.warnings.length > 0
      }
    });
  } catch (error) {
    console.error('Error in POST /api/projects/:id/scenes/:sceneId/shots/lock:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});
```

**Response Structure**:
```typescript
// Success (200)
{
  success: true,
  scene: {
    id: string,
    status: 'shot_list_ready',  // CRITICAL: Must be set
    shotListLockedAt: string,
    sceneNumber: number,
    shotCount: number,
    forcedLock?: boolean  // True if warnings were bypassed
  }
}

// Validation Errors (400) - Cannot be bypassed
{
  error: 'Shot list validation failed',
  errors: ValidationError[],
  canForce: false
}

// Validation Warnings (409) - Can be bypassed with force=true
{
  error: 'Shot list has warnings',
  warnings: ValidationWarning[],
  canForce: true
}
```

**Security & Correctness**:
- ✅ Check ownership: scene → branch → project → user_id
- ✅ Idempotent: Return success if already locked (no error)
- ✅ Race condition protection: `.is('shot_list_locked_at', null)` in UPDATE
- ✅ Audit trail: Store forced lock metadata in scene.metadata JSONB
- ✅ **CRITICAL**: Explicit `status = 'shot_list_ready'` transition

---

### **Task 4: Backend Unlock Endpoint with Invalidation Cascade** ⚠️ CRITICAL REDESIGN
**Purpose**: Allow unlocking shot list with invalidation of downstream artifacts

**File**: `backend/src/routes/projects.ts`

**New Endpoint**: `POST /api/projects/:id/scenes/:sceneId/shots/unlock`

**Request Body**:
```typescript
{
  reason?: string;  // Optional audit trail
  confirm?: boolean; // Required if downstream work exists
}
```

**Complete Implementation**:

```typescript
// POST /api/projects/:id/scenes/:sceneId/shots/unlock
router.post('/:id/scenes/:sceneId/shots/unlock', async (req, res) => {
  try {
    const { id: projectId, sceneId } = req.params;
    const { reason, confirm = false } = req.body;
    const userId = req.user!.id;

    // 1. Verify ownership
    const { data: project, error: projectError } = await supabase
      .from('projects')
      .select('id, active_branch_id')
      .eq('id', projectId)
      .eq('user_id', userId)
      .single();

    if (projectError || !project) {
      return res.status(404).json({ error: 'Project not found' });
    }

    // 2. Fetch scene
    const { data: scene, error: sceneError } = await supabase
      .from('scenes')
      .select('id, status, shot_list_locked_at, dependencies_extracted_at')
      .eq('id', sceneId)
      .eq('branch_id', project.active_branch_id)
      .single();

    if (sceneError || !scene) {
      return res.status(404).json({ error: 'Scene not found' });
    }

    // 3. Check if locked
    if (!scene.shot_list_locked_at) {
      return res.status(400).json({ error: 'Shot list is not locked' });
    }

    // 4. Check for downstream work (frames, videos)
    const hasDownstreamWork = scene.status === 'frames_locked' || scene.status === 'video_complete';

    if (hasDownstreamWork) {
      // Count affected artifacts
      const { data: shots } = await supabase
        .from('shots')
        .select('id')
        .eq('scene_id', sceneId);

      const shotIds = (shots || []).map(s => s.id);

      const { data: frames } = await supabase
        .from('frames')
        .select('id')
        .in('shot_id', shotIds);

      const { data: videos } = await supabase
        .from('videos')
        .select('id')
        .in('shot_id', shotIds);

      const framesAffected = frames?.length || 0;
      const videosAffected = videos?.length || 0;

      // Estimate regeneration cost
      const estimatedCost = framesAffected * 0.05 + videosAffected * 2.50;

      // If not confirmed, return warning
      if (!confirm) {
        return res.status(409).json({
          error: 'Unlocking will invalidate downstream artifacts',
          details: {
            framesAffected,
            videosAffected,
            estimatedCost: estimatedCost.toFixed(2),
            message: `This will invalidate ${framesAffected} frames and ${videosAffected} videos. Estimated regeneration cost: $${estimatedCost.toFixed(2)}`
          },
          requiresConfirmation: true
        });
      }

      // User confirmed - proceed with invalidation
      // Mark frames as invalidated (not deleted)
      if (framesAffected > 0) {
        await supabase
          .from('frames')
          .update({ status: 'invalidated' })
          .in('shot_id', shotIds);
      }

      // Mark videos as invalidated (not deleted)
      if (videosAffected > 0) {
        await supabase
          .from('videos')
          .update({ status: 'invalidated' })
          .in('shot_id', shotIds);
      }

      // Log invalidation event (if invalidation_logs table exists)
      try {
        await supabase
          .from('invalidation_logs')
          .insert({
            branch_id: project.active_branch_id,
            invalidation_type: 'upstream_edit',
            invalidated_scenes: [sceneId],
            estimated_regen_cost: estimatedCost,
            reason: reason || 'Shot list unlocked for editing',
            created_by: userId
          });
      } catch (logError) {
        // Logging failure shouldn't block unlock
        console.warn('Failed to log invalidation:', logError);
      }
    }

    // 5. Unlock scene
    // Determine previous status (revert to pre-lock state)
    const previousStatus = scene.dependencies_extracted_at ? 'dependencies_extracted' : 'draft';

    const { data: unlockedScene, error: updateError } = await supabase
      .from('scenes')
      .update({
        shot_list_locked_at: null,
        status: previousStatus,  // CRITICAL: Revert status
        updated_at: new Date().toISOString()
      })
      .eq('id', sceneId)
      .select('*')
      .single();

    if (updateError || !unlockedScene) {
      console.error('Failed to unlock scene:', updateError);
      return res.status(500).json({ error: 'Failed to unlock shot list' });
    }

    // 6. Return success
    res.json({
      success: true,
      scene: {
        id: unlockedScene.id,
        status: unlockedScene.status,
        shotListLockedAt: null
      },
      invalidated: hasDownstreamWork ? {
        frames: hasDownstreamWork ? 0 : undefined,  // Replace with actual counts
        videos: hasDownstreamWork ? 0 : undefined
      } : undefined
    });
  } catch (error) {
    console.error('Error in POST /api/projects/:id/scenes/:sceneId/shots/unlock:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});
```

**Response Structure**:
```typescript
// Warning: Downstream work exists (409)
{
  error: 'Unlocking will invalidate downstream artifacts',
  details: {
    framesAffected: number,
    videosAffected: number,
    estimatedCost: string,  // e.g., "125.00"
    message: string
  },
  requiresConfirmation: true
}

// Success (200)
{
  success: true,
  scene: {
    id: string,
    status: 'draft' | 'dependencies_extracted',  // Reverted status
    shotListLockedAt: null
  },
  invalidated?: {
    frames: number,
    videos: number
  }
}
```

**Why This Design Is Better**:
1. ✅ **Follows Architecture**: Uses deterministic invalidation pattern from database schema
2. ✅ **Preserves Data**: Marks artifacts as `invalidated` instead of deleting them
3. ✅ **Audit Trail**: Logs to `invalidation_logs` table with cost estimate
4. ✅ **User Control**: Requires explicit confirmation before invalidating expensive work
5. ✅ **Status Consistency**: Reverts scene status to pre-lock state

---

### **Task 5: Frontend Validation Logic** ⚠️ CRITICAL AUTO-SAVE FIX APPLIED
**Purpose**: Client-side validation with CORRECT auto-save synchronization

**File**: `src/components/pipeline/Stage7ShotList.tsx`

**Changes**:

1. **Add State**:
```typescript
const [validationErrors, setValidationErrors] = useState<ValidationError[]>([]);
const [validationWarnings, setValidationWarnings] = useState<ValidationWarning[]>([]);
const [showValidationModal, setShowValidationModal] = useState(false);
const [isLocking, setIsLocking] = useState(false);
const [isEditable, setIsEditable] = useState(true);  // NEW: Control edit state during lock
```

2. **Add Validation Function** (matches backend validation):
```typescript
const validateShotsLocally = (): { errors: ValidationError[], warnings: ValidationWarning[] } => {
  const errors: ValidationError[] = [];
  const warnings: ValidationWarning[] = [];
  
  // CRITICAL: Check for empty shot list
  if (shots.length === 0) {
    errors.push({ 
      shotId: 'scene', 
      shotOrder: -1, 
      field: 'shot_count', 
      message: 'Scene must have at least one shot', 
      severity: 'error' 
    });
    return { errors, warnings };
  }

  // Check for duplicate shot IDs
  const shotIdCounts = new Map<string, number>();
  shots.forEach(shot => {
    const count = shotIdCounts.get(shot.shotId) || 0;
    shotIdCounts.set(shot.shotId, count + 1);
  });

  shotIdCounts.forEach((count, shotId) => {
    if (count > 1) {
      errors.push({
        shotId,
        shotOrder: -1,
        field: 'shotId',
        message: `Duplicate shot ID "${shotId}" found`,
        severity: 'error'
      });
    }
  });
  
  shots.forEach((shot, index) => {
    // Required fields
    if (!shot.action?.trim()) {
      errors.push({ shotId: shot.shotId, shotOrder: index, field: 'action', message: 'Action is required', severity: 'error' });
    }
    if (!shot.setting?.trim()) {
      errors.push({ shotId: shot.shotId, shotOrder: index, field: 'setting', message: 'Setting is required', severity: 'error' });
    }
    if (!shot.camera?.trim()) {
      errors.push({ shotId: shot.shotId, shotOrder: index, field: 'camera', message: 'Camera is required', severity: 'error' });
    }
    
    // Duration validation
    if (shot.duration < 1) {
      errors.push({ shotId: shot.shotId, shotOrder: index, field: 'duration', message: 'Minimum duration is 1 second', severity: 'error' });
    } else if (shot.duration > 30) {
      errors.push({ shotId: shot.shotId, shotOrder: index, field: 'duration', message: 'Maximum duration is 30 seconds', severity: 'error' });
    } else if (shot.duration < 4) {
      warnings.push({ shotId: shot.shotId, shotOrder: index, field: 'duration', message: `Duration ${shot.duration}s is very short`, severity: 'warning' });
    } else if (shot.duration > 12) {
      warnings.push({ shotId: shot.shotId, shotOrder: index, field: 'duration', message: `Duration ${shot.duration}s is unusually long`, severity: 'warning' });
    }
  });
  
  // Total duration check (dynamic based on shot count)
  const totalDuration = shots.reduce((sum, s) => sum + s.duration, 0);
  const expectedMin = shots.length * 4;
  const expectedMax = shots.length * 15;
  
  if (totalDuration < expectedMin) {
    warnings.push({ shotId: 'scene', shotOrder: -1, field: 'total_duration', message: `Scene duration (${totalDuration}s) is unusually short for ${shots.length} shots`, severity: 'warning' });
  } else if (totalDuration > expectedMax) {
    warnings.push({ shotId: 'scene', shotOrder: -1, field: 'total_duration', message: `Scene duration (${totalDuration}s) is very long for ${shots.length} shots`, severity: 'warning' });
  }
  
  return { errors, warnings };
};
```

3. **CRITICAL: Fix Auto-Save Race Condition**:
```typescript
const handleLockShotList = async () => {
  try {
    setIsLocking(true);
    setIsEditable(false);  // CRITICAL: Prevent new edits during lock process
    
    // CRITICAL: Force immediate save of ALL dirty shots (bypass debounce)
    if (pendingUpdates.size > 0) {
      toast({
        title: 'Saving final changes...',
        description: 'Please wait',
      });
      
      // Create array of all dirty shots with their updates
      const dirtyUpdates: Array<{ shotId: string; updates: Partial<Shot> }> = [];
      for (const [shotId, updates] of pendingUpdates.entries()) {
        dirtyUpdates.push({ shotId, updates });
      }
      
      // Save all updates immediately (bypass debounce)
      const savePromises = dirtyUpdates.map(({ shotId, updates }) =>
        shotService.updateShot(projectId, sceneId, shotId, updates)
      );
      
      try {
        await Promise.all(savePromises);
        setPendingUpdates(new Map());  // Clear after successful save
      } catch (saveError) {
        console.error('Failed to save pending changes:', saveError);
        toast({
          title: 'Failed to save changes',
          description: 'Please try again',
          variant: 'destructive',
        });
        setIsEditable(true);  // Re-enable editing on error
        setIsLocking(false);
        return;
      }
      
      // CRITICAL: Brief delay to ensure database transaction commits
      await new Promise(resolve => setTimeout(resolve, 150));
    }
    
    // Local validation preview
    const { errors, warnings } = validateShotsLocally();
    setValidationErrors(errors);
    setValidationWarnings(warnings);
    
    if (errors.length > 0 || warnings.length > 0) {
      setShowValidationModal(true);
      setIsEditable(true);  // Re-enable editing if validation fails
      return;
    }
    
    // No issues, proceed to lock
    await lockShotList(false);
    
  } catch (error) {
    console.error('Lock handler error:', error);
    setIsEditable(true);
    toast({
      title: 'Failed to lock shot list',
      description: error instanceof Error ? error.message : 'Unknown error',
      variant: 'destructive',
    });
  } finally {
    setIsLocking(false);
  }
};

const lockShotList = async (force: boolean) => {
  try {
    const response = await shotService.lockShotList(projectId, sceneId, force);
    
    toast({
      title: 'Shot list locked',
      description: `Scene is ready for asset assignment`,
    });
    
    setShowValidationModal(false);
    onComplete(); // Proceed to next stage
  } catch (error: any) {
    if (error.status === 409) {
      // Server returned warnings - show modal
      setValidationWarnings(error.data.warnings);
      setShowValidationModal(true);
      setIsEditable(true);  // Allow fixes
    } else if (error.status === 400) {
      // Server validation errors
      setValidationErrors(error.data.errors);
      setShowValidationModal(true);
      setIsEditable(true);  // Allow fixes
      toast({
        title: 'Validation failed',
        description: `${error.data.errors.length} issues must be fixed`,
        variant: 'destructive',
      });
    } else {
      setIsEditable(true);  // Allow retry
      toast({
        title: 'Failed to lock shot list',
        description: error.message,
        variant: 'destructive',
      });
    }
  }
};
```

4. **Add Real-Time Validation Indicators** (Hybrid Approach):
```typescript
// Helper function for field validation state
const getFieldValidationState = (shot: Shot, field: string): 'valid' | 'warning' | 'error' => {
  if (!isEditable) return 'valid';  // Don't show indicators when locked
  
  if (field === 'action' && !shot.action?.trim()) return 'error';
  if (field === 'camera' && !shot.camera?.trim()) return 'error';
  if (field === 'setting' && !shot.setting?.trim()) return 'error';
  
  if (field === 'duration') {
    if (shot.duration < 1 || shot.duration > 30) return 'error';
    if (shot.duration < 4 || shot.duration > 12) return 'warning';
  }
  
  return 'valid';
};

// Apply to input fields (example for action field):
<Textarea
  value={selectedShot.action}
  onChange={(e) => handleShotUpdate(selectedShot.id, 'action', e.target.value)}
  disabled={!isEditable}
  className={cn(
    "resize-none",
    getFieldValidationState(selectedShot, 'action') === 'error' && 'border-b-2 border-b-red-500',
    getFieldValidationState(selectedShot, 'action') === 'warning' && 'border-b-2 border-b-yellow-500'
  )}
  placeholder="Describe the atomic physical action for this shot..."
  rows={4}
/>
```

5. **Update Button UI**:
```typescript
<Button 
  variant="default" 
  onClick={handleLockShotList}
  disabled={!isEditable || isSaving || shots.length === 0 || isLocking}
  className="bg-primary hover:bg-primary/90 text-primary-foreground"
>
  {isLocking ? (
    <>
      <Loader2 className="w-4 h-4 mr-2 animate-spin" />
      Locking...
    </>
  ) : (
    <>
      <Check className="w-4 h-4 mr-2" />
      Lock Shot List & Proceed
    </>
  )}
</Button>
```

**Why This Fix Is Critical**:

**The Problem**: Original plan had a race condition where:
1. User types final field value → triggers 800ms debounce
2. User immediately clicks "Lock" (< 800ms)
3. Validation runs against stale data (field not yet saved)
4. Lock fails with confusing error: "field is required" (but user just typed it!)

**The Solution**:
1. ✅ **Disable editing immediately** (`setIsEditable(false)`) when lock starts
2. ✅ **Force synchronous save** of ALL dirty fields (bypass debounce entirely)
3. ✅ **Wait for database commit** (150ms settle delay)
4. ✅ **Then proceed with validation**

**Real-World Test Scenario**:
- User fills out "camera" field (last required field)
- Types "Medium Shot" and clicks "Lock" within 100ms
- System force-saves immediately instead of waiting 800ms
- Validation sees fresh data
- Lock succeeds ✅

---

### **Task 6: Validation Warning Modal** ✅ ENHANCED WITH FORCE LOCK RULES
**Purpose**: Display validation errors/warnings with proper force lock handling

**File**: `src/components/pipeline/Stage7ShotList.tsx`

**Component**: New Dialog at end of component (similar to split dialog)

**Features**:
1. Show errors in red with icons (blocking, cannot be bypassed)
2. Show warnings in yellow with icons (can be bypassed with force)
3. List each issue with shot ID and field
4. Click issue to jump to that shot (set as selectedShot and close modal)
5. Buttons:
   - "Fix Issues" (if errors) → close modal, stay on page
   - "Go Back" (if warnings only) → close modal
   - "Lock Anyway" (ONLY if warnings exist AND no errors) → `lockShotList(true)`

**UI Structure**:
```tsx
<Dialog open={showValidationModal} onOpenChange={setShowValidationModal}>
  <DialogContent className="sm:max-w-2xl">
    <DialogHeader>
      <DialogTitle className="flex items-center gap-2">
        <AlertTriangle className="w-5 h-5 text-yellow-500" />
        Shot List Validation
      </DialogTitle>
      <DialogDescription>
        {validationErrors.length > 0 
          ? 'Please fix the following issues before locking:'
          : 'The following warnings were found. You can fix them or proceed anyway.'}
      </DialogDescription>
    </DialogHeader>
    
    <ScrollArea className="max-h-96">
      <div className="space-y-4">
        {/* Errors Section */}
        {validationErrors.length > 0 && (
          <div>
            <h4 className="text-sm font-medium text-destructive mb-2 flex items-center gap-2">
              <AlertCircle className="w-4 h-4" />
              Errors ({validationErrors.length})
            </h4>
            <div className="space-y-2">
              {validationErrors.map((error, i) => (
                <button
                  key={i}
                  onClick={() => {
                    const shot = shots.find(s => s.shotId === error.shotId);
                    if (shot) setSelectedShot(shot);
                    setShowValidationModal(false);
                  }}
                  className="w-full text-left p-3 rounded-md bg-destructive/10 border border-destructive/30 hover:bg-destructive/20 transition-colors"
                >
                  <div className="flex items-start gap-2">
                    <Badge variant="destructive" className="font-mono text-xs">
                      {error.shotId}
                    </Badge>
                    <span className="text-sm text-foreground">{error.message}</span>
                  </div>
                </button>
              ))}
            </div>
          </div>
        )}
        
        {/* Warnings Section */}
        {validationWarnings.length > 0 && (
          <div>
            <h4 className="text-sm font-medium text-yellow-600 dark:text-yellow-500 mb-2 flex items-center gap-2">
              <AlertTriangle className="w-4 h-4" />
              Warnings ({validationWarnings.length})
            </h4>
            <div className="space-y-2">
              {validationWarnings.map((warning, i) => (
                <button
                  key={i}
                  onClick={() => {
                    if (warning.shotId !== 'scene') {
                      const shot = shots.find(s => s.shotId === warning.shotId);
                      if (shot) setSelectedShot(shot);
                    }
                    setShowValidationModal(false);
                  }}
                  className="w-full text-left p-3 rounded-md bg-yellow-500/10 border border-yellow-500/30 hover:bg-yellow-500/20 transition-colors"
                >
                  <div className="flex items-start gap-2">
                    <Badge variant="outline" className="font-mono text-xs border-yellow-500/50">
                      {warning.shotId}
                    </Badge>
                    <span className="text-sm text-foreground">{warning.message}</span>
                  </div>
                </button>
              ))}
            </div>
          </div>
        )}
      </div>
    </ScrollArea>
    
    <DialogFooter className="flex-row gap-2 sm:gap-2">
      <Button
        variant="ghost"
        onClick={() => setShowValidationModal(false)}
      >
        {validationErrors.length > 0 ? 'Fix Issues' : 'Go Back'}
      </Button>
      
      {validationErrors.length === 0 && validationWarnings.length > 0 && (
        <Button
          onClick={() => lockShotList(true)}
          disabled={isLocking}
          className="bg-primary hover:bg-primary/90"
        >
          {isLocking ? (
            <>
              <Loader2 className="w-4 h-4 mr-2 animate-spin" />
              Locking...
            </>
          ) : (
            <>
              <Check className="w-4 h-4 mr-2" />
              Lock Anyway
            </>
          )}
        </Button>
      )}
    </DialogFooter>
  </DialogContent>
</Dialog>
```

---

### **Task 7: Frontend Shot Service Updates**
**Purpose**: Add API methods for locking/unlocking

**File**: `src/lib/services/shotService.ts`

**New Methods**:

```typescript
async lockShotList(
  projectId: string, 
  sceneId: string, 
  force: boolean = false
): Promise<{ success: boolean; scene: any }> {
  const session = await supabase.auth.getSession();
  const token = session.data.session?.access_token;
  
  const response = await fetch(
    `${API_BASE_URL}/api/projects/${projectId}/scenes/${sceneId}/shots/lock`,
    {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({ force })
    }
  );
  
  const data = await response.json();
  
  if (!response.ok) {
    const error: any = new Error(data.error || 'Failed to lock shot list');
    error.status = response.status;
    error.data = data;
    throw error;
  }
  
  return data;
}

async unlockShotList(
  projectId: string, 
  sceneId: string, 
  reason?: string
): Promise<{ success: boolean }> {
  const session = await supabase.auth.getSession();
  const token = session.data.session?.access_token;
  
  const response = await fetch(
    `${API_BASE_URL}/api/projects/${projectId}/scenes/${sceneId}/shots/unlock`,
    {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({ reason })
    }
  );
  
  const data = await response.json();
  
  if (!response.ok) {
    throw new Error(data.error || 'Failed to unlock shot list');
  }
  
  return data;
}
```

---

### **Task 8: Visual Indicators for Locked Shots**
**Purpose**: Show read-only state when shot list is locked

**File**: `src/components/pipeline/Stage7ShotList.tsx`

**Changes**:
1. **Fetch scene lock status**:
```typescript
const [isSceneLocked, setIsSceneLocked] = useState(false);

useEffect(() => {
  const checkLockStatus = async () => {
    const scenes = await sceneService.fetchScenes(projectId);
    const currentScene = scenes.find(s => s.id === sceneId);
    setIsSceneLocked(!!currentScene?.shotListLockedAt);
  };
  checkLockStatus();
}, [projectId, sceneId]);
```

2. **Disable editing when locked**:
   - Disable all input fields: `disabled={isSceneLocked || isSaving}`
   - Disable split/merge/delete buttons: `disabled={isSceneLocked || ...}`
   - Show lock banner at top of inspector
   - Change button text to "Shot List Locked" with lock icon

3. **Lock Banner Component**:
```tsx
{isSceneLocked && (
  <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-3 mb-4">
    <div className="flex items-center gap-2">
      <Lock className="w-4 h-4 text-blue-500" />
      <div>
        <p className="text-sm font-medium text-blue-500">Shot List Locked</p>
        <p className="text-xs text-muted-foreground">
          This shot list has been approved. Unlock to make changes.
        </p>
      </div>
      <Button
        variant="outline"
        size="sm"
        onClick={handleUnlock}
        className="ml-auto"
      >
        Unlock
      </Button>
    </div>
  </div>
)}
```

---

### **Task 9: Scene Type Updates**
**Purpose**: Add lock timestamp to Scene interface

**File**: `src/types/scene.ts`

**Changes**:
```typescript
export interface Scene {
  // ... existing fields ...
  shotListLockedAt?: string; // ISO timestamp when shot list was locked
}
```

**File**: `src/lib/services/sceneService.ts`

**Changes**: Update scene transformation to include `shotListLockedAt`:
```typescript
shotListLockedAt: scene.shot_list_locked_at || (scene as any).shotListLockedAt
```

---

### **Task 10: Backend Scene Fetch Updates**
**Purpose**: Return lock status in scene queries

**File**: `backend/src/routes/projects.ts`

**Changes**: Add `shot_list_locked_at` to scene SELECT queries (lines ~460, ~584):
```typescript
.select('id, scene_number, slug, status, script_excerpt, end_state_summary, end_frame_thumbnail_url, updated_at, expected_characters, expected_location, expected_props, dependencies_extracted_at, shot_list_locked_at')
```

---

### **Task 11: Testing & Documentation** ⚠️ CRITICAL TEST SCENARIOS INCLUDED

**Critical Manual Testing Scenarios** (MUST TEST):

1. **Auto-Save Race Condition Test** ⚠️ HIGHEST PRIORITY
   - Fill out all shots except final required field ("camera" on last shot)
   - Type "Medium Shot" in camera field
   - **Immediately** click "Lock Shot List & Proceed" (< 100ms after typing)
   - ✅ **Expected**: Edit is saved before validation runs, lock succeeds
   - ❌ **Failure**: Error modal says "camera is required" even though user just typed it

2. **Empty Shot List Test**
   - Delete all shots from scene
   - Click "Lock Shot List & Proceed"
   - ✅ **Expected**: Error modal: "Scene must have at least one shot"

3. **Duplicate Shot ID Test**
   - Manually edit two shots to have the same shot ID (e.g., both "3A")
   - Click "Lock Shot List & Proceed"
   - ✅ **Expected**: Error modal: "Duplicate shot ID '3A' found"

4. **Character Name Typo Test**
   - Scene has `expected_characters: ['John Doe', 'Jane Smith']`
   - In shot, set `charactersForeground: ['Jhon Doe']` (typo)
   - Click "Lock Shot List & Proceed"
   - ✅ **Expected**: Warning modal: "Did you mean 'John Doe'?"
   - Click "Lock Anyway" → success

5. **Unlock with Frames Test**
   - Lock shot list (scene status → `shot_list_ready`)
   - Progress to Stage 10, generate frames
   - Return to Stage 7, click "Unlock"
   - ✅ **Expected**: Modal shows frame count and cost estimate
   - Click "Unlock & Invalidate" → frames marked as `invalidated` (not deleted)

6. **Scene Status Transition Test**
   - Lock shot list
   - Verify in database: `shot_list_locked_at IS NOT NULL` AND `status = 'shot_list_ready'`
   - Unlock shot list
   - Verify: `shot_list_locked_at IS NULL` AND `status = 'draft'` (or `dependencies_extracted`)

7. **Force Lock Audit Trail Test**
   - Create shot with duration = 2s (unusual but valid)
   - Click "Lock Shot List & Proceed" → warning modal
   - Click "Lock Anyway"
   - Verify in database: `scene.metadata.forcedLock = true` and `forcedLockWarnings` array populated

**Standard Testing Checklist**:
- [ ] Lock shot list with valid shots → success
- [ ] Lock shot list with missing required fields → error modal (cannot bypass)
- [ ] Lock shot list with warnings → warning modal (can force)
- [ ] Unlock shot list (no downstream work) → editable again
- [ ] Try to edit locked shot list → all fields disabled
- [ ] Navigate away and back → lock status persists
- [ ] Real-time validation indicators show correct colors

**Unit Tests** (Backend):

Create `backend/src/tests/shotValidation.test.ts`:

```typescript
import { shotValidationService } from '../services/shotValidationService';

describe('ShotValidationService', () => {
  describe('validateShots', () => {
    it('should error on empty shot list', () => {
      const result = shotValidationService.validateShots([]);
      expect(result.valid).toBe(false);
      expect(result.errors[0].message).toContain('at least one shot');
    });

    it('should error on missing required fields', () => {
      const shot = { 
        id: '1', shotId: '1A', shotOrder: 0, sceneId: 'scene1',
        duration: 8, action: '', camera: 'MS', setting: 'INT',
        dialogue: '', charactersForeground: [], charactersBackground: []
      };
      const result = shotValidationService.validateShots([shot]);
      expect(result.errors).toContainEqual(
        expect.objectContaining({ field: 'action', severity: 'error' })
      );
    });

    it('should error on duration out of bounds', () => {
      const shot = { 
        id: '1', shotId: '1A', shotOrder: 0, sceneId: 'scene1',
        duration: 0.5, action: 'Walk', camera: 'MS', setting: 'INT',
        dialogue: '', charactersForeground: [], charactersBackground: []
      };
      const result = shotValidationService.validateShots([shot]);
      expect(result.errors.some(e => e.field === 'duration')).toBe(true);
    });

    it('should warn on unusual duration', () => {
      const shot = { 
        id: '1', shotId: '1A', shotOrder: 0, sceneId: 'scene1',
        duration: 2, action: 'Walk', camera: 'MS', setting: 'INT',
        dialogue: '', charactersForeground: [], charactersBackground: []
      };
      const result = shotValidationService.validateShots([shot]);
      expect(result.warnings.some(w => w.field === 'duration')).toBe(true);
    });

    it('should error on duplicate shot IDs', () => {
      const shots = [
        { id: '1', shotId: '1A', shotOrder: 0, sceneId: 'scene1', duration: 8, action: 'Walk', camera: 'MS', setting: 'INT', dialogue: '', charactersForeground: [], charactersBackground: [] },
        { id: '2', shotId: '1A', shotOrder: 1, sceneId: 'scene1', duration: 6, action: 'Talk', camera: 'CU', setting: 'INT', dialogue: '', charactersForeground: [], charactersBackground: [] }
      ];
      const result = shotValidationService.validateShots(shots);
      expect(result.errors.some(e => e.field === 'shotId')).toBe(true);
    });

    it('should warn on character name mismatch', () => {
      const shot = { 
        id: '1', shotId: '1A', shotOrder: 0, sceneId: 'scene1',
        duration: 8, action: 'Walk', camera: 'MS', setting: 'INT',
        dialogue: '', charactersForeground: ['Jhon Doe'], charactersBackground: []
      };
      const result = shotValidationService.validateShots([shot], {
        expected_characters: ['John Doe']
      });
      expect(result.warnings.some(w => w.message.includes('Did you mean'))).toBe(true);
    });
  });
});
```

**Integration Tests** (Backend):

Create `backend/src/tests/shotLocking.test.ts`:

```typescript
describe('Shot List Locking Endpoints', () => {
  describe('POST /api/projects/:id/scenes/:sceneId/shots/lock', () => {
    it('should lock shot list with valid shots', async () => {
      // Setup: Create project, scene, valid shots
      const res = await request(app)
        .post(`/api/projects/${projectId}/scenes/${sceneId}/shots/lock`)
        .set('Authorization', `Bearer ${token}`)
        .send({ force: false });
      
      expect(res.status).toBe(200);
      expect(res.body.scene.shotListLockedAt).toBeTruthy();
      expect(res.body.scene.status).toBe('shot_list_ready');
    });

    it('should return 400 on validation errors', async () => {
      // Setup: Scene with invalid shots (missing required field)
      const res = await request(app)
        .post(`/api/projects/${projectId}/scenes/${sceneId}/shots/lock`)
        .set('Authorization', `Bearer ${token}`);
      
      expect(res.status).toBe(400);
      expect(res.body.errors).toBeDefined();
      expect(res.body.canForce).toBe(false);
    });

    it('should return 409 on validation warnings', async () => {
      // Setup: Scene with unusual duration
      const res = await request(app)
        .post(`/api/projects/${projectId}/scenes/${sceneId}/shots/lock`)
        .set('Authorization', `Bearer ${token}`);
      
      expect(res.status).toBe(409);
      expect(res.body.warnings).toBeDefined();
      expect(res.body.canForce).toBe(true);
    });

    it('should be idempotent', async () => {
      // Lock once
      await request(app)
        .post(`/api/projects/${projectId}/scenes/${sceneId}/shots/lock`)
        .set('Authorization', `Bearer ${token}`);
      
      // Lock again
      const res = await request(app)
        .post(`/api/projects/${projectId}/scenes/${sceneId}/shots/lock`)
        .set('Authorization', `Bearer ${token}`);
      
      expect(res.status).toBe(200);
    });
  });

  describe('POST /api/projects/:id/scenes/:sceneId/shots/unlock', () => {
    it('should unlock without confirmation if no downstream work', async () => {
      const res = await request(app)
        .post(`/api/projects/${projectId}/scenes/${sceneId}/shots/unlock`)
        .set('Authorization', `Bearer ${token}`)
        .send({ confirm: false });
      
      expect(res.status).toBe(200);
    });

    it('should require confirmation if frames exist', async () => {
      // Setup: Create frames for scene
      const res = await request(app)
        .post(`/api/projects/${projectId}/scenes/${sceneId}/shots/unlock`)
        .set('Authorization', `Bearer ${token}`)
        .send({ confirm: false });
      
      expect(res.status).toBe(409);
      expect(res.body.details.framesAffected).toBeGreaterThan(0);
      expect(res.body.requiresConfirmation).toBe(true);
    });
  });
});
```

**Documentation Updates**:
- [ ] Update `Phase-4-Status-Implementations.md` with Feature 4.5 completion status
- [ ] Add validation rules to `._docs/architecture-and-rules.md`
- [ ] Update `._docs/user-flow.md` with lock/unlock workflow
- [ ] Document forced lock policy in PRD

---

## Critical Changes from Original Plan (v0 → v1)

**Three Critical Fixes Applied**:

1. ⚠️ **Auto-Save Race Condition Fix** (Task 5)
   - **Problem**: User could click "Lock" before debounced save completed, causing validation to run against stale data
   - **Solution**: Force immediate synchronous save of ALL dirty fields, disable editing during lock process, add 150ms settle delay

2. ⚠️ **Scene Status Transition Fix** (Task 1 & 3)
   - **Problem**: Migration didn't include `shot_list_ready` status, lock endpoint wouldn't update scene.status
   - **Solution**: Update CHECK constraint to include `shot_list_ready`, explicitly set status in lock endpoint

3. ⚠️ **Unlock Endpoint Redesign** (Task 4)
   - **Problem**: Hard block when frames exist violates deterministic invalidation architecture
   - **Solution**: Allow unlock with cost estimate, mark artifacts as `invalidated` instead of blocking, log to `invalidation_logs`

**Enhancements Added**:

4. ✅ **Character Name Validation** (Task 2)
   - Validates against `scene.expected_characters` with fuzzy matching
   - Prevents "ghost character" problem that causes Stage 8 failures

5. ✅ **Minimum Shot Count & ID Uniqueness** (Task 2)
   - Error if scene has zero shots
   - Error if duplicate shot IDs exist

6. ✅ **Force Lock Audit Trail** (Task 3)
   - Stores forced lock metadata in scene.metadata
   - Records bypassed warnings for debugging

7. ✅ **Hybrid Validation UX** (Task 5)
   - Real-time indicators (colored borders) during editing
   - Gate validation at lock time

---

## Implementation Order

**Phase 1: Critical Fixes** (Must complete before testing)
**Duration**: 4-6 hours

1. ✅ Task 1: Database migration (with `shot_list_ready` status)
2. ✅ Task 2: Validation service (with minimum count, uniqueness, character validation)
3. ✅ Task 3: Lock endpoint (with explicit status transition and audit trail)
4. ✅ Task 4: Unlock endpoint (with invalidation cascade)

**Phase 2: Frontend Integration**
**Duration**: 3-4 hours

5. ✅ Task 7: Shot service methods (lock/unlock API)
6. ✅ Task 5: Validation logic (with auto-save race fix)
7. ✅ Task 6: Warning modal (with proper force lock handling)

**Phase 3: Polish & Production Readiness**
**Duration**: 2-3 hours

8. ✅ Task 8: Visual indicators (locked state, real-time validation)
9. ✅ Task 9: Type updates (shotListLockedAt field)
10. ✅ Task 10: Backend scene fetch updates
11. ✅ Task 11: Testing & documentation

**Total Estimated Time**: 9-13 hours

---

## Implementation Checklist

Use this checklist to track progress through all tasks:

### Phase 1: Critical Fixes (4-6 hours)

**Task 1: Database Migration** ✅ CRITICAL
- [ ] Create `backend/migrations/014_add_shot_list_locking.sql`
- [ ] Add `shot_list_locked_at` column (TIMESTAMPTZ, nullable)
- [ ] Update `scenes_status_check` constraint to include `'shot_list_ready'`
- [ ] Create partial index on `shot_list_locked_at`
- [ ] Add rollback SQL in comments
- [ ] Run migration: `npm run migrate`
- [ ] Verify in database: `\d scenes` shows new column and status

**Task 2: Validation Service** ✅ CRITICAL
- [ ] Create `backend/src/services/shotValidationService.ts`
- [ ] Implement `validateShots()` method
- [ ] Add minimum shot count check (≥ 1 shot)
- [ ] Add shot ID uniqueness check
- [ ] Add required field validation (action, setting, camera)
- [ ] Add duration validation (1-30s hard limit, 4-12s warning)
- [ ] Add character name validation with fuzzy matching
- [ ] Add total duration bounds (dynamic based on shot count)
- [ ] Implement Levenshtein distance helper
- [ ] Export `ValidationResult`, `ValidationError` interfaces
- [ ] Export `shotValidationService` singleton

**Task 3: Lock Endpoint** ✅ CRITICAL
- [ ] Add route: `POST /api/projects/:id/scenes/:sceneId/shots/lock`
- [ ] Verify project ownership
- [ ] Check idempotent (already locked → return success)
- [ ] Fetch all shots for scene
- [ ] Call `shotValidationService.validateShots()`
- [ ] Return 400 if errors (canForce: false)
- [ ] Return 409 if warnings and not forced (canForce: true)
- [ ] Update scene: `shot_list_locked_at = NOW()`, `status = 'shot_list_ready'`
- [ ] Store forced lock metadata if `force: true`
- [ ] Return success with scene data

**Task 4: Unlock Endpoint** ✅ CRITICAL
- [ ] Add route: `POST /api/projects/:id/scenes/:sceneId/shots/unlock`
- [ ] Verify ownership
- [ ] Check scene is locked
- [ ] Check for downstream work (frames, videos)
- [ ] If downstream exists and not confirmed → return 409 with cost estimate
- [ ] Mark frames as `invalidated` (if exist)
- [ ] Mark videos as `invalidated` (if exist)
- [ ] Log to `invalidation_logs` table
- [ ] Update scene: `shot_list_locked_at = NULL`, revert status
- [ ] Return success

### Phase 2: Frontend Integration (3-4 hours)

**Task 7: Shot Service Methods**
- [ ] Open `src/lib/services/shotService.ts`
- [ ] Add `lockShotList(projectId, sceneId, force)` method
- [ ] Add `unlockShotList(projectId, sceneId, reason?, confirm?)` method
- [ ] Handle error responses with status codes (400, 409)
- [ ] Extract error details for display

**Task 5: Frontend Validation** ✅ CRITICAL AUTO-SAVE FIX
- [ ] Open `src/components/pipeline/Stage7ShotList.tsx`
- [ ] Add state: `isEditable`, `validationErrors`, `validationWarnings`, `showValidationModal`, `isLocking`
- [ ] Implement `validateShotsLocally()` (matches backend validation)
- [ ] Implement `getFieldValidationState()` for real-time indicators
- [ ] Implement `handleLockShotList()` with auto-save race fix:
  - [ ] Set `isEditable = false`
  - [ ] Force save all dirty shots (bypass debounce)
  - [ ] Wait 150ms for database commit
  - [ ] Run validation
  - [ ] Show modal if issues
  - [ ] Call `lockShotList(false)`
- [ ] Implement `lockShotList(force)` with error handling
- [ ] Apply real-time validation to input fields (colored borders)
- [ ] Update button UI (disabled when `!isEditable`)

**Task 6: Warning Modal**
- [ ] Add Dialog component below split dialog
- [ ] Show errors section (red) if `validationErrors.length > 0`
- [ ] Show warnings section (yellow) if `validationWarnings.length > 0`
- [ ] Make issues clickable (jump to shot, close modal)
- [ ] Add "Fix Issues" button (if errors)
- [ ] Add "Go Back" button (if warnings only)
- [ ] Add "Lock Anyway" button (ONLY if warnings and no errors)
- [ ] Handle `isLocking` state during force lock

### Phase 3: Polish & Testing (2-3 hours)

**Task 8: Visual Indicators**
- [ ] Add `isSceneLocked` state
- [ ] Fetch scene lock status on mount
- [ ] Disable all inputs when locked (`disabled={isSceneLocked}`)
- [ ] Disable split/merge/delete buttons when locked
- [ ] Add lock banner above inspector
- [ ] Add "Unlock" button to banner
- [ ] Handle unlock with confirmation if needed

**Task 9: Type Updates**
- [ ] Open `src/types/scene.ts`
- [ ] Add `shotListLockedAt?: string` to Scene interface
- [ ] Open `src/lib/services/sceneService.ts`
- [ ] Update transformation: `shotListLockedAt: scene.shot_list_locked_at || ...`

**Task 10: Backend Scene Fetch**
- [ ] Open `backend/src/routes/projects.ts`
- [ ] Add `shot_list_locked_at` to scene SELECT queries (lines ~460, ~584)
- [ ] Include in scene transform/response

**Task 11: Testing**
- [ ] Run all 7 critical manual test scenarios
- [ ] Write unit tests for `shotValidationService`
- [ ] Write integration tests for lock/unlock endpoints
- [ ] Update documentation:
  - [ ] `Phase-4-Status-Implementations.md`
  - [ ] `._docs/architecture-and-rules.md`
  - [ ] `._docs/user-flow.md`

---

## Post-Implementation Verification

After completing all tasks, verify the following:

✅ **Database**:
- [ ] `scenes` table has `shot_list_locked_at` column
- [ ] `scenes_status_check` constraint includes `'shot_list_ready'`
- [ ] Index `idx_scenes_shot_list_locked` exists

✅ **Backend**:
- [ ] `shotValidationService.ts` file exists and exports correctly
- [ ] Lock endpoint works: `POST /api/projects/:id/scenes/:sceneId/shots/lock`
- [ ] Unlock endpoint works: `POST /api/projects/:id/scenes/:sceneId/shots/unlock`
- [ ] Scene queries return `shot_list_locked_at` field

✅ **Frontend**:
- [ ] Shot service has `lockShotList()` and `unlockShotList()` methods
- [ ] Stage7ShotList handles auto-save race condition
- [ ] Validation modal shows errors vs warnings correctly
- [ ] "Lock Anyway" button only appears for warnings (not errors)
- [ ] Real-time validation indicators work (colored borders)
- [ ] Locked state disables all editing

✅ **Integration**:
- [ ] Lock with valid shots → scene status becomes `shot_list_ready`
- [ ] Lock with errors → cannot proceed (canForce: false)
- [ ] Lock with warnings → can force bypass
- [ ] Unlock without downstream work → immediate success
- [ ] Unlock with frames → requires confirmation, marks invalidated
- [ ] Auto-save race test passes (type → immediate lock → success)

---

## Success Criteria

Feature 4.5 is complete when:

1. ✅ Users can lock shot list only when all validation passes
2. ✅ Scene status updates to `shot_list_ready` after lock
3. ✅ Errors block locking (cannot be bypassed)
4. ✅ Warnings allow forced locking with audit trail
5. ✅ Auto-save race condition is resolved (no stale data)
6. ✅ Unlock with frames requires confirmation and marks invalidated
7. ✅ All critical test scenarios pass
8. ✅ Documentation is updated

---

**Implementation Status**: Ready for development
**Estimated Completion**: 9-13 hours
**Priority**: High (blocks Phase B stages 8-12)

---

## Design Decisions (Based on AI Analysis)

All open questions have been resolved based on comprehensive AI analysis and architectural best practices:

### 1. **Warnings vs Errors** ✅ RESOLVED
**Decision**: Two-tier validation system
- **Hard Errors** (un-bypassable): < 1s or > 30s (API/quality limits)
- **Warnings** (bypassable): < 4s or > 12s (unusual but valid creative choices)

**Rationale**: Filmmakers intentionally use unusual durations for creative effect. Hard errors only for physical/technical impossibilities.

---

### 2. **Unlock Restrictions** ✅ RESOLVED
**Decision**: Allow unlock with invalidation cascade
- If frames/videos exist → Show cost estimate + require confirmation
- Mark downstream artifacts as `invalidated` (NOT deleted)
- Log to `invalidation_logs` table for audit trail

**Rationale**: Follows deterministic invalidation architecture from database schema. Blocking changes would violate core system design.

---

### 3. **Shot Coherence** ✅ RESOLVED
**Decision**: Include character validation in Feature 4.5
- **Implemented**: Validate character names against `scene.expected_characters`
- **Fuzzy matching**: Suggest corrections for typos (Levenshtein distance < 3)
- **Warning level**: Can be bypassed but prevents "ghost character" problem
- **Deferred**: Dialogue gap detection and continuity flag validation (post-4.5)

**Rationale**: Character validation prevents costly Stage 8 failures. Low-effort, high-value addition.

---

### 4. **Validation Scope** ✅ RESOLVED
**Decision**: Hybrid approach (real-time + gate)
- **Real-time**: Subtle visual indicators (colored borders) as user edits
  - Empty required field → red bottom border
  - Invalid duration → red/yellow border
  - No toast notifications or blocking modals
- **Gate**: Full, strict validation at lock time
  - Server-side validation (source of truth)
  - Modal with all errors and warnings
  - Includes coherence checks (character names, etc.)

**Rationale**: Real-time reduces "validation shock" by surfacing issues during editing. Gate ensures data integrity with authoritative server check.

---

### 5. **Force Lock** ✅ RESOLVED
**Decision**: Bypass warnings only, never errors

| Validation Type | Can Force Lock? | Rationale |
|-----------------|-----------------|-----------|
| **Errors** | ❌ No | Data integrity violations (empty required fields, invalid duration ranges) |
| **Warnings** | ✅ Yes | Creative decisions (unusual durations, character name typos, total duration) |

**Implementation**: Forced locks store audit metadata in `scene.metadata.forcedLock` with list of bypassed warnings.

**Rationale**: Errors indicate broken/corrupted data that would cause downstream failures. Warnings indicate unusual but valid creative choices.