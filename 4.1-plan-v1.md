# Feature 4.1: Scene Extraction & Parsing Implementation Plan

## Overview

Enhance the existing scene extraction system to properly parse scene headings with DAY/NIGHT detection, generate descriptive slugs, ensure correct scene ordering, and align TypeScript types with the database schema. The scenes table already exists, and basic extraction logic is in place, but needs enhancement for production use.

**Architectural Improvements**: This plan implements a **"Gate Approach"** for scene extraction to align with the project's "Immutability by Default" principle. Scene extraction is treated as a transactional gate that only commits to the `scenes` table when transitioning from Stage 4 to Stage 5, preventing constant "Deterministic Invalidation" triggers. The plan also addresses critical risks around Scene ID Stability (preserving downstream work) and Branching Logic (forcing branch creation when editing locked stages with Phase B data).

## Current State Analysis

**Already Implemented:**

- `scenes` table schema (migration 003) with all required fields
- Basic `extractScenes()` method in `scriptService.ts` (lines 266-317)
- Scene persistence endpoint `PUT /api/projects/:id/scenes` (lines 426-498)
- Integration in Stage 4 that calls extraction and persistence on script approval
- Stage 6 Script Hub UI (currently using mock data)

**Gaps Identified:**

1. Scene heading parser only detects INT./EXT., missing DAY/NIGHT parsing
2. Slug generation is too basic (doesn't include location/time context, no uniqueness guarantee)
3. TypeScript `Scene` type status values don't match database schema
4. Scene boundary detection could be more robust
5. No GET endpoint to fetch scenes for Stage 6
6. **Architectural Risk**: No "Gate" approach - extraction should only commit to `scenes` table on Stage 4→5 transition, not on every edit
7. **Scene ID Stability**: Re-extraction generates new UUIDs, potentially orphaning downstream work (Stages 6-12)
8. **Branching Logic**: No explicit check for active branch state or downstream Phase B data before re-extraction

## Implementation Tasks

### Task 1: Align TypeScript Types with Database Schema

**File**: `src/types/scene.ts`

**Issue**: Database uses `'shot_list_ready'`, `'frames_locked'`, `'video_complete'`, `'continuity_broken'` but TypeScript uses `'shot-list-locked'`, `'frames-locked'`, `'video-complete'`.

**Changes**:

- Update `SceneStatus` type to match database enum values exactly
- Update `Scene` interface to match database fields:
                - `header` → should be derived from `script_excerpt` (first line)
                - `openingAction` → should be derived from `script_excerpt`
                - `expectedCharacters` → needs extraction from script (future enhancement)
                - `expectedLocation` → needs extraction from script (future enhancement)
                - Add `scriptExcerpt` field to match database
                - Ensure `status` uses database values

### Task 2: Enhance Scene Heading Parser

**File**: `src/lib/services/scriptService.ts`

**Current regex**: `/^(INT\.|EXT\.)\s+(.+)$/i` (line 275)

**Enhancements needed**:

1. Parse DAY/NIGHT/CONTINUOUS from scene headings

                        - Pattern: `INT. LOCATION - DAY` or `EXT. LOCATION - NIGHT`
                        - Handle variations: `- DAY`, `- NIGHT`, `- CONTINUOUS`, `- LATER`, `- MOMENTS LATER`

2. Extract location name from heading
3. More robust boundary detection:

                        - Handle scene headings that may have extra whitespace
                        - Handle scene headings with numbers (e.g., `INT. KITCHEN - DAY 1`)
                        - Ensure scene content includes everything until next scene heading

**Implementation**:

```typescript
// Enhanced regex pattern
const sceneHeadingRegex = /^(INT\.|EXT\.)\s+(.+?)(?:\s*-\s*(DAY|NIGHT|CONTINUOUS|LATER|MOMENTS LATER|DAWN|DUSK))?$/i;

// Parse heading components
interface ParsedHeading {
  type: 'INT' | 'EXT';
  location: string;
  timeOfDay?: string;
  fullHeading: string;
}
```

### Task 3: Improve Slug Generation with Uniqueness Guarantee

**File**: `src/lib/services/scriptService.ts` (lines 415-422)

**Current**: Basic slug from heading (lowercase, replace spaces with hyphens)

**Enhancement**: Generate descriptive slugs that include:

- Scene type (int/ext)
- Location (sanitized)
- Time of day (if present)
- Scene number for uniqueness (to handle duplicate locations)
- Example: `int-kitchen-day-1`, `int-kitchen-day-5`, `ext-city-street-night-2`

**Implementation**:

- Use parsed heading components to build structured slug
- Sanitize location name (remove special chars, handle multi-word locations)
- Include time of day in slug for better identification
- **Critical**: Append scene number to ensure uniqueness when same location appears multiple times
- Format: `{type}-{location}-{timeOfDay}-{sceneNumber}` or `{type}-{location}-{sceneNumber}` if no timeOfDay

### Task 4: Enhance Scene Extraction Logic

**File**: `src/lib/services/scriptService.ts` (lines 266-317)

**Improvements**:

1. Better content aggregation:

                        - Include scene heading in content
                        - Capture all lines until next scene heading
                        - Handle edge cases (empty scenes, scenes at end of script)

2. Validate extracted scenes:

                        - Ensure each scene has non-empty content
                        - Log warnings for malformed scenes

3. Scene numbering:

                        - Ensure sequential numbering (1, 2, 3...)
                        - Handle re-extraction (should maintain or reset numbering)
                        - **Note**: Scene numbering is independent of slug generation; slugs include scene number for uniqueness

**Edge Cases to Handle**:

- Scripts with no scene headings
- Scene headings without content
- Multiple consecutive scene headings
- Scene headings in dialogue or action blocks (false positives)

### Task 5: Create Scene Fetching API Endpoint

**File**: `backend/src/routes/projects.ts`

**New Endpoint**: `GET /api/projects/:id/scenes`

**Purpose**: Fetch all scenes for a project's active branch for Stage 6 Script Hub

**Implementation**:

- Get project and validate ownership
- Get active branch ID
- Query scenes table ordered by `scene_number`
- Return scenes with all fields needed by Stage 6:
                - `id`, `scene_number`, `slug`, `status`, `script_excerpt`
                - Transform `script_excerpt` to extract `header` and `openingAction` for UI

**Response Format**:

```typescript
{
  scenes: Array<{
    id: string;
    sceneNumber: number;
    slug: string;
    status: SceneStatus;
    scriptExcerpt: string;
    header: string; // First line of script_excerpt
    openingAction: string; // First few lines after header
    // ... other fields
  }>
}
```

### Task 6: Create Scene Service in Frontend

**File**: `src/lib/services/sceneService.ts` (new file)

**Purpose**: Centralized service for scene operations

**Methods**:

- `fetchScenes(projectId: string): Promise<Scene[]>`
- `getScene(sceneId: string): Promise<Scene>`
- `updateSceneStatus(sceneId: string, status: SceneStatus): Promise<void>`
- `previewScenes(script: string): Promise<Scene[]>` - Extract scenes in-memory for preview (draft phase)

**Implementation**:

- Use Supabase client or API endpoints
- Handle authentication
- Transform database format to TypeScript types
- Extract `header` and `openingAction` from `script_excerpt`
- `previewScenes()` uses `extractScenes()` without persistence (for Stage 4 preview)

### Task 6.5: Implement Scene ID Stability (Diff & Match Logic)

**File**: `backend/src/routes/projects.ts` (in `PUT /api/projects/:id/scenes` endpoint)

**Purpose**: Preserve existing scene IDs when slugs match to avoid orphaning downstream work

**Risk**: If re-extraction generates new UUIDs for every scene, all downstream progress in Stages 6–12 (shot lists, frames, videos) will be orphaned because their `scene_id` references will no longer exist.

**Implementation**:

1. Before inserting new scenes, fetch existing scenes for the active branch
2. For each extracted scene:
   - Check if a scene with matching `slug` and `scene_number` exists
   - If match found: **retain the original `scene_id`** and update only the `script_excerpt` field
   - If no match: create new scene with new UUID
3. Handle deleted scenes (scenes that existed before but not in new extraction):
   - Log warning about potential downstream impact
   - Optionally mark as `'continuity_broken'` status
4. Return mapping of old→new scene IDs for logging/debugging

**Edge Cases**:
- Scene reordering (scene_number changes but slug matches)
- Scene splitting (one scene becomes two)
- Scene merging (two scenes become one)
- **Note**: For complex changes, prefer creating new branch rather than attempting to preserve IDs

### Task 7: Stage 4/5 Transition Logic (Gate Approach)

**File**: `src/components/pipeline/Stage4MasterScript.tsx`

**Architectural Principle**: Scene extraction is a **transactional gate**, not a continuous background process. This prevents "Deterministic Invalidation" from triggering constantly and aligns with "Immutability by Default" principle.

**Two-Phase Approach**:

#### Phase A: Draft Phase (While in Stage 4)
- **"Preview Scenes" Button**: Allow users to see extracted scenes without committing
  - Calls `sceneService.previewScenes(formattedScript)` (in-memory extraction)
  - Displays scene count and list in a modal/drawer
  - Optionally saves preview to `stage_states.content.scenes` JSONB field for persistence across page refreshes
  - **Does NOT** write to `scenes` table

#### Phase B: Commit Phase (Stage 4→5 Transition)
- **"Approve Master Script" / "Proceed to Stage 5" Button**: Triggers "Lock & Extract"
  - Validates extracted scenes (ensure at least one scene, validate scene content is non-empty)
  - **Checks for Active Branch and Downstream Phase B Data**:
    - If Stage 4 is already locked AND Phase B has begun (scenes have shot lists, frames, or videos):
      - Show "Downstream Impact Warning" modal explaining that re-extraction will:
        - Potentially orphan downstream work if scene IDs change
        - Require creating a new branch to preserve existing work
      - Force user to create new branch before proceeding
    - If no downstream data exists: proceed with extraction
  - Calls `scriptService.extractScenes()` and `scriptService.persistScenes()`
  - Backend applies Scene ID Stability logic (Task 6.5) to preserve existing scene IDs where possible
  - Locks Stage 4 (prevents further edits without branching)
  - Shows scene count in success toast
  - Navigates to Stage 5

**Implementation Details**:

- Extract scenes using latest script content from editor
- Handle extraction errors gracefully with user-friendly error messages
- Ensure extraction engine can handle manual formatting quirks (robust parsing)
- Only commit results to production `scenes` table when Stage 4 is locked (moving to Stage 5)

**Branching Logic**:
- Check project's active branch state before extraction
- If editing a locked Stage 4 with downstream Phase B data, **must** force branch creation
- New branch gets fresh scene extraction without attempting to preserve IDs

### Task 8: Replace Mock Data in Stage 6

**File**: `src/components/pipeline/Stage6ScriptHub.tsx`

**Current**: Uses `mockScenes` array (lines 22-86)

**Changes**:

- Remove `mockScenes` constant
- Add `useEffect` to fetch scenes on mount using `sceneService.fetchScenes()`
- Add loading state while fetching
- Add error handling
- Transform fetched scenes to match UI expectations:
                - Extract `header` from `script_excerpt` (first line)
                - Extract `openingAction` from `script_excerpt` (lines after header)
                - Map database status to TypeScript status
                - Set default values for `expectedCharacters`, `expectedLocation` (will be enhanced in future)

### Task 9: Add Scene Extraction Tests

**File**: `src/lib/services/__tests__/scriptService.test.ts` (new file)

**Test Cases**:

1. Extract scenes from standard formatted script
2. Handle DAY/NIGHT in scene headings
3. Handle CONTINUOUS/LATER variations
4. Extract scenes with proper numbering
5. Handle edge cases (no scenes, malformed headings)
6. Slug generation with various heading formats
7. Slug uniqueness when same location appears multiple times

**File**: `backend/src/routes/__tests__/projects.test.ts` (add tests)

**Test Cases for Scene ID Stability**:

1. Re-extraction preserves scene IDs when slugs match
2. Re-extraction creates new IDs for new scenes
3. Re-extraction handles deleted scenes (scenes removed from script)
4. Re-extraction handles scene reordering
5. Branching creates fresh scenes without ID preservation

## Data Flow

### Draft Phase (Stage 4 - Preview Only)

```
Stage 4 Master Script (formattedScript)
    ↓
User clicks "Preview Scenes" button
    ↓
sceneService.previewScenes(formattedScript)
    ↓
scriptService.extractScenes(formattedScript) [in-memory only]
    ↓
Enhanced Parser:
 - Detects INT./EXT. headings
 - Parses DAY/NIGHT/CONTINUOUS
 - Extracts location
 - Generates descriptive slugs (with scene number)
 - Aggregates scene content
    ↓
Scene[] array (in-memory)
    ↓
Display in preview modal/drawer
    ↓
Optionally save to stage_states.content.scenes (JSONB) for persistence
    ↓
[NO COMMIT TO scenes TABLE]
```

### Commit Phase (Stage 4→5 Transition - Gate)

```
Stage 4 Master Script (formattedScript)
    ↓
User clicks "Approve Master Script" / "Proceed to Stage 5"
    ↓
Validation:
 - Check active branch state
 - Check for downstream Phase B data (shot lists, frames, videos)
    ↓
If locked Stage 4 + Phase B data exists:
    ↓
Show "Downstream Impact Warning" → Force branch creation
    ↓
If no downstream data OR new branch:
    ↓
scriptService.extractScenes(formattedScript)
    ↓
Enhanced Parser (same as draft phase)
    ↓
Scene[] array with:
 - sceneNumber (sequential)
 - slug (descriptive + scene number for uniqueness)
 - content (full script excerpt)
    ↓
scriptService.persistScenes(projectId, scenes)
    ↓
PUT /api/projects/:id/scenes
    ↓
Backend: Scene ID Stability Logic (Task 6.5)
 - Fetch existing scenes for active branch
 - Match by slug + scene_number
 - Preserve existing scene_id where possible
 - Update script_excerpt for matched scenes
 - Create new scenes for unmatched
    ↓
Database: scenes table (committed)
    ↓
Lock Stage 4 (prevent edits without branching)
    ↓
Navigate to Stage 5
    ↓
GET /api/projects/:id/scenes (for Stage 6)
    ↓
Stage 6 Script Hub (real data from scenes table)
```

## Type Alignment Matrix

| Database Field | TypeScript Field | Transformation Needed |

|---------------|-----------------|----------------------|

| `scene_number` | `sceneNumber` | Direct mapping |

| `slug` | `slug` | Direct mapping |

| `script_excerpt` | `scriptExcerpt` | Direct mapping |

| `status` | `status` | Direct mapping (after type update) |

| `script_excerpt` (first line) | `header` | Extract from `script_excerpt` |

| `script_excerpt` (after header) | `openingAction` | Extract from `script_excerpt` |

| N/A | `expectedCharacters` | Set empty array (future: extract from script) |

| N/A | `expectedLocation` | Extract from scene heading (future: full extraction) |

## Success Criteria

1. ✅ Scene extraction correctly parses INT/EXT with DAY/NIGHT
2. ✅ Slugs are descriptive, include location/time context, and are unique (include scene number)
3. ✅ Scenes are numbered sequentially (1, 2, 3...)
4. ✅ Scene content includes full script excerpt
5. ✅ TypeScript types match database schema exactly
6. ✅ Stage 6 displays real scenes from database (no mock data)
7. ✅ Scene fetching API endpoint works correctly
8. ✅ Edge cases are handled gracefully (empty scripts, malformed headings)
9. ✅ **Gate Approach**: Scene extraction only commits to `scenes` table on Stage 4→5 transition
10. ✅ **Preview Functionality**: Users can preview scenes in Stage 4 without committing
11. ✅ **Scene ID Stability**: Re-extraction preserves existing scene IDs when slugs match (prevents orphaning downstream work)
12. ✅ **Branching Logic**: System forces branch creation if editing locked Stage 4 with downstream Phase B data
13. ✅ **Downstream Impact Warning**: Users are warned before re-extraction that could affect existing work

## Files to Modify

1. `src/types/scene.ts` - Update SceneStatus and Scene interface
2. `src/lib/services/scriptService.ts` - Enhance extractScenes() and generateSlug() (with scene number in slug)
3. `backend/src/routes/projects.ts` - Add GET /api/projects/:id/scenes endpoint AND enhance PUT endpoint with Scene ID Stability logic
4. `src/lib/services/sceneService.ts` - New file for scene operations (including previewScenes method)
5. `src/components/pipeline/Stage6ScriptHub.tsx` - Replace mock data with real fetching
6. `src/components/pipeline/Stage4MasterScript.tsx` - Implement Gate Approach (preview button, downstream impact warning, branching checks)

## Dependencies

- Existing `scenes` table (migration 003) ✅
- Existing scene persistence endpoint ✅
- Stage 4 script generation ✅
- Supabase client configuration ✅

## Future Enhancements (Out of Scope for 4.1)

- Extract `expectedCharacters` from script content (LLM-based)
- Extract `expectedLocation` from script content (LLM-based)
- Continuity risk analysis (Feature 4.2)
- Scene end-state summary generation (Feature 4.4)
- **Stage 5 Functionality**: Stage 5 (Asset Extraction & Definition) uses extracted assets from the global asset library, not scenes. Scene extraction (Feature 4.1) is a prerequisite for Stage 6 (Script Hub) and later stages. Stage 5 functionality will be addressed in future Phase 4 tasks.

