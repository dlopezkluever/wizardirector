# Feature 5.3: Status Metadata Tags - Development Plan

**Phase:** 5 of ._docs/dev-tasklist.md
**Feature:** 5.3 - Status Metadata Tags  
**Purpose:** Track visual conditions (muddy, bloody, torn) across scenes with persistence logic  
**Dependencies:** Features 5.1 (Scene Asset Instances), 5.2 (Stage 8 UI) completed

---

## OVERVIEW

Feature 5.3 enhances the existing scene asset instance system with comprehensive status metadata tag functionality. While `status_tags` and `carry_forward` columns already exist in `scene_asset_instances` (migration 015) and the `StatusTagsEditor` component is implemented, this feature will:

1. **Add comprehensive tag UI patterns** across Stage 8 components
2. **Implement tag-based search and filtering** for assets
3. **Build tag persistence logic** for automatic carry-forward across scenes
4. **Add tag propagation prompts** to guide users on continuity decisions
5. **Enhance tag visualization** with category-based styling

**Current State (from 5.1 & 5.2):**
- ✅ Database: `status_tags TEXT[]` and `carry_forward BOOLEAN` exist (migration 015)
- ✅ Backend: Routes support reading/writing tags and carry_forward
- ✅ Frontend: `StatusTagsEditor` component exists (Task 9 of 5.2)
- ✅ Types: `SceneAssetInstance` includes `status_tags` and `carry_forward`

**What's Missing (5.3 scope):**
- ❌ Tag display in asset list panels (chips/badges)
- ❌ Tag-based filtering and search
- ❌ Automatic tag carry-forward prompt when entering new scenes
- ❌ Tag category system with semantic colors
- ❌ Tag autocomplete/suggestions
- ❌ Tag history and evolution tracking

---

## TECHNICAL ARCHITECTURE

### Database Layer (Already Complete ✅)

**Table:** `scene_asset_instances` (migration 015)
```sql
status_tags TEXT[]         -- e.g., ['muddy', 'torn_shirt', 'bloody']
carry_forward BOOLEAN DEFAULT TRUE  -- persist to next scene?
```

**Validation Trigger:** `validate_status_tags()` (from database-schema doc, lines 1111-1130)
- Tags only allowed when scene status is `shot_list_ready` or later (Stage 7+)
- This trigger is **documented but not yet migrated** (see Task 1)

### Backend API Layer (Already Complete ✅)

**Routes:** `backend/src/routes/sceneAssets.ts`
- `GET /api/projects/:projectId/scenes/:sceneId/assets` - Returns instances with `status_tags` and `carry_forward`
- `PUT /api/projects/:projectId/scenes/:sceneId/assets/:instanceId` - Updates `status_tags` and `carry_forward`
- `POST /api/projects/:projectId/scenes/:sceneId/assets` - Creates instances with tags

**Zod Validation:**
```typescript
statusTags: z.array(z.string()).optional()
carryForward: z.boolean().optional()
```

### Frontend Service Layer (Already Complete ✅)

**Service:** `src/lib/services/sceneAssetService.ts`
- `createSceneAsset()` - Accepts `statusTags` and `carryForward`
- `updateSceneAsset()` - Updates tags and carry-forward flag


### Frontend Component Layer (Partial - Needs Extension)

**Existing:**
- ✅ `StatusTagsEditor` - Add/remove tags with carry-forward toggle
- ✅ `VisualStateEditorPanel` - Uses StatusTagsEditor

**Needs:**
- ❌ Tag display in `SceneAssetListPanel` (chips per asset)
- ❌ Tag filter controls
- ❌ Tag carry-forward prompt modal
- ❌ Tag category system
- ❌ Tag autocomplete

---

## IMPLEMENTATION TASK LIST

### ✅ **PREREQUISITES (Already Completed)**

- ✅ Migration 015: `scene_asset_instances` with `status_tags` and `carry_forward`
- ✅ Migration 017: Modification tracking columns
- ✅ Backend routes: CRUD with tag support
- ✅ Frontend types: `SceneAssetInstance` with tags
- ✅ `StatusTagsEditor` component
- ✅ Stage 8 UI with asset list and editor panels

---

## TASK BREAKDOWN

---

### **Task 1: Database Validation Trigger (Optional Enhancement)**

**Goal:** Add database-level validation that tags can only be set after Stage 7 (shot_list_ready)

**Files:**
- NEW: `backend/migrations/018_status_tags_validation.sql`

**Implementation:**

Create migration `018_status_tags_validation.sql`:

```sql
-- Migration 018: Status Tags Validation
-- Feature 5.3: Enforce tags only after Stage 7 (shot_list_ready)
-- Reference: database-schema-state-transition-matrix.md lines 1111-1130

-- Validation function: status tags only allowed when scene is shot_list_ready or later
CREATE OR REPLACE FUNCTION validate_status_tags()
RETURNS TRIGGER AS $$
BEGIN
    -- Only validate if status_tags array has elements
    IF array_length(NEW.status_tags, 1) > 0 THEN
        IF NOT EXISTS (
            SELECT 1 FROM scenes s
            WHERE s.id = NEW.scene_id 
              AND s.status IN ('shot_list_ready', 'frames_locked', 'video_complete')
        ) THEN
            RAISE EXCEPTION 'Status tags can only be applied after Stage 7 (shot list must be locked)';
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply trigger
DROP TRIGGER IF EXISTS validate_tags ON scene_asset_instances;
CREATE TRIGGER validate_tags
BEFORE INSERT OR UPDATE ON scene_asset_instances
FOR EACH ROW EXECUTE FUNCTION validate_status_tags();

-- Add comment
COMMENT ON FUNCTION validate_status_tags() IS 'Enforces that status_tags can only be set when scene.status is shot_list_ready or later (Stage 7+)';
```

**Testing:**
- Manual test: Try to add tags to a scene with `status = 'draft'` (should fail)
- Manual test: Add tags to a scene with `status = 'shot_list_ready'` (should succeed)

**User Impact:**
- Stage 8 UI will show error toast if user tries to add tags before Stage 7 is complete
- Frontend should check scene status and disable tag editing if scene is not ready

**Decision Point:** This is **optional** because:
- The frontend already gates Stage 8 access by scene status
- Adds database-level safety but may complicate testing
- Recommend implementing if data integrity is critical

**Deliverable:** Migration file ready to run (user will apply manually per AGENTS.md)

---

### **Task 2: Tag Category System & Semantic Styling**

**Goal:** Create a tag category system with semantic colors for different condition types

**Files:**
- NEW: `src/lib/constants/statusTags.ts` - Tag categories and colors
- UPDATE: `src/components/pipeline/Stage8/StatusTagsEditor.tsx` - Add category colors

**Implementation:**

**2.1 - Tag Categories Constant**

Create `src/lib/constants/statusTags.ts`:

```typescript
/**
 * Status Tag Categories & Semantic Styling
 * Feature 5.3: Categorize tags for consistent UI colors
 * Reference: ui-and-theme-rules.md for color palette
 */

export type StatusTagCategory = 
  | 'condition'     // Physical state (muddy, dirty, bloody)
  | 'damage'        // Damage (torn, ripped, broken)
  | 'temporal'      // Time-based (wet, dry, aged)
  | 'appearance'    // Appearance (clean, polished, worn)
  | 'custom';       // User-defined

export interface StatusTagDefinition {
  name: string;
  category: StatusTagCategory;
  description?: string;
}

// Predefined common tags with categories
export const COMMON_STATUS_TAGS: StatusTagDefinition[] = [
  // Condition tags
  { name: 'muddy', category: 'condition', description: 'Covered in mud' },
  { name: 'bloody', category: 'condition', description: 'Blood visible' },
  { name: 'dirty', category: 'condition', description: 'Unclean or grimy' },
  { name: 'dusty', category: 'condition', description: 'Covered in dust' },
  { name: 'sweaty', category: 'condition', description: 'Perspiration visible' },
  
  // Damage tags
  { name: 'torn', category: 'damage', description: 'Fabric or material torn' },
  { name: 'ripped', category: 'damage', description: 'Severely damaged' },
  { name: 'broken', category: 'damage', description: 'Structurally damaged' },
  { name: 'cracked', category: 'damage', description: 'Surface cracked' },
  { name: 'shattered', category: 'damage', description: 'Completely broken' },
  
  // Temporal tags
  { name: 'wet', category: 'temporal', description: 'Recently wet or damp' },
  { name: 'dry', category: 'temporal', description: 'Dried out' },
  { name: 'aged', category: 'temporal', description: 'Shows signs of age' },
  { name: 'weathered', category: 'temporal', description: 'Exposed to elements' },
  
  // Appearance tags
  { name: 'clean', category: 'appearance', description: 'Pristine condition' },
  { name: 'polished', category: 'appearance', description: 'Shiny and maintained' },
  { name: 'worn', category: 'appearance', description: 'Used but intact' },
  { name: 'faded', category: 'appearance', description: 'Color diminished' },
];

// Category colors (aligned with ui-and-theme-rules.md)
export const TAG_CATEGORY_COLORS: Record<StatusTagCategory, {
  bg: string;
  text: string;
  border: string;
}> = {
  condition: {
    bg: 'bg-amber-500/20',
    text: 'text-amber-400',
    border: 'border-amber-500/30',
  },
  damage: {
    bg: 'bg-destructive/20',
    text: 'text-destructive',
    border: 'border-destructive/30',
  },
  temporal: {
    bg: 'bg-info/20',
    text: 'text-info',
    border: 'border-info/30',
  },
  appearance: {
    bg: 'bg-success/20',
    text: 'text-success',
    border: 'border-success/30',
  },
  custom: {
    bg: 'bg-secondary',
    text: 'text-secondary-foreground',
    border: 'border-border',
  },
};

/**
 * Get category for a tag (returns 'custom' if not found)
 */
export function getTagCategory(tagName: string): StatusTagCategory {
  const found = COMMON_STATUS_TAGS.find(t => t.name === tagName.toLowerCase());
  return found?.category ?? 'custom';
}

/**
 * Get color classes for a tag based on category
 */
export function getTagColors(tagName: string) {
  const category = getTagCategory(tagName);
  return TAG_CATEGORY_COLORS[category];
}

/**
 * Get autocomplete suggestions (lowercase tag names).
 * When projectTags is provided, tags already used in the current project/branch
 * are shown first to encourage consistency (e.g. avoid "muddy" vs "dirt-covered").
 */
export function getTagSuggestions(query: string, projectTags?: string[]): string[] {
  const q = query.toLowerCase();
  const fromCommon = !q
    ? COMMON_STATUS_TAGS.slice(0, 8).map(t => t.name)
    : COMMON_STATUS_TAGS
        .filter(t => t.name.includes(q) || t.description?.toLowerCase().includes(q))
        .slice(0, 8)
        .map(t => t.name);
  if (!projectTags?.length) return fromCommon;
  const used = projectTags.filter(t => !q || t.includes(q));
  const usedSet = new Set(used);
  const rest = fromCommon.filter(t => !usedSet.has(t));
  return [...used, ...rest].slice(0, 8);
}
```

**2.2 - Update StatusTagsEditor with Category Colors**

Update `src/components/pipeline/Stage8/StatusTagsEditor.tsx`:

```typescript
// Add import
import { getTagColors, getTagSuggestions } from '@/lib/constants/statusTags';

// Update Badge rendering (around line 56)
{tags.map(tag => {
  const colors = getTagColors(tag);
  return (
    <Badge
      key={tag}
      variant="secondary"
      className={cn(
        'gap-1 pr-1 border',
        colors.bg,
        colors.text,
        colors.border
      )}
    >
      {tag}
      {!disabled && (
        <button
          type="button"
          className="rounded-full p-0.5 hover:bg-muted hover:text-destructive transition-colors"
          onClick={() => handleRemoveTag(tag)}
          aria-label={`Remove ${tag}`}
        >
          <X className="w-3 h-3" />
        </button>
      )}
    </Badge>
  );
})}
```

**2.3 - Add Autocomplete to Input**

Add state for suggestions (around line 34):

```typescript
const [inputValue, setInputValue] = useState('');
const [suggestions, setSuggestions] = useState<string[]>([]);
const [showSuggestions, setShowSuggestions] = useState(false);

// Update handleAddTag to use suggestions
const handleAddTag = (tag?: string) => {
  const trimmed = (tag ?? inputValue).trim().toLowerCase();
  if (trimmed && !tags.includes(trimmed)) {
    onChange([...tags, trimmed]);
    setInputValue('');
    setSuggestions([]);
    setShowSuggestions(false);
  }
};

// Add input change handler
const handleInputChange = (value: string) => {
  setInputValue(value);
  if (value.trim()) {
    setSuggestions(getTagSuggestions(value));
    setShowSuggestions(true);
  } else {
    setSuggestions([]);
    setShowSuggestions(false);
  }
};
```

Add suggestions dropdown after Input (around line 90):

```typescript
<div className="relative flex gap-2">
  <div className="relative flex-1">
    <Input
      value={inputValue}
      onChange={e => handleInputChange(e.target.value)}
      onKeyDown={e => {
        if (e.key === 'Enter') {
          e.preventDefault();
          handleAddTag();
        }
        if (e.key === 'Escape') {
          setShowSuggestions(false);
        }
      }}
      onFocus={() => {
        if (inputValue.trim()) setShowSuggestions(true);
      }}
      onBlur={() => {
        // Delay to allow clicking suggestions
        setTimeout(() => setShowSuggestions(false), 200);
      }}
      placeholder="Add tag (e.g. muddy, torn, bloody)"
    />
    {showSuggestions && suggestions.length > 0 && (
      <div className="absolute z-10 w-full mt-1 rounded-lg border border-border bg-card shadow-lg">
        <div className="p-1 space-y-0.5 max-h-48 overflow-y-auto">
          {suggestions.map(suggestion => (
            <button
              key={suggestion}
              type="button"
              className="w-full text-left px-3 py-1.5 text-sm rounded hover:bg-muted transition-colors"
              onClick={() => {
                handleAddTag(suggestion);
              }}
            >
              {suggestion}
            </button>
          ))}
        </div>
      </div>
    )}
  </div>
  <Button type="button" size="sm" variant="outline" onClick={() => handleAddTag()}>
    <Plus className="w-4 h-4" />
  </Button>
</div>
```

**Autocomplete prioritization:** In the search and editor components, pass tags already used in the current project/branch (e.g. from the current scene's assets or from `listSceneAssets` across the branch) into `getTagSuggestions(query, projectTags)`. Show those first in the dropdown so users tend to reuse "muddy" instead of typing "dirt-covered" for the same visual state—reducing tag soup and improving filter effectiveness.

**Deliverable:**
- Tag category system with semantic colors (condition=amber, damage=red, temporal=blue, appearance=green)
- Autocomplete suggestions in StatusTagsEditor (predefined + project-used tags prioritized)
- 18 predefined common tags

---

### **Task 3: Tag Display in Asset List Panel**

**Goal:** Show status tags as chips in the asset list panel for quick visual reference

**Files:**
- UPDATE: `src/components/pipeline/Stage8/SceneAssetListPanel.tsx`

**Implementation:**

**3.1 - Add Tag Display to Asset List Items**

Update `SceneAssetListPanel.tsx` around line 110 (inside the asset card):

```typescript
// Import tag utilities
import { getTagColors } from '@/lib/constants/statusTags';
import { Badge } from '@/components/ui/badge';

// Inside the asset item (after source badge, before the end):
{/* Status Tags */}
{instance.status_tags && instance.status_tags.length > 0 && (
  <div className="flex flex-wrap gap-1 mt-1.5">
    {instance.status_tags.slice(0, 3).map(tag => {
      const colors = getTagColors(tag);
      return (
        <Badge
          key={tag}
          variant="secondary"
          className={cn(
            'text-[10px] px-1.5 py-0 h-4 border',
            colors.bg,
            colors.text,
            colors.border
          )}
        >
          {tag}
        </Badge>
      );
    })}
    {instance.status_tags.length > 3 && (
      <Badge
        variant="secondary"
        className="text-[10px] px-1.5 py-0 h-4 text-muted-foreground"
      >
        +{instance.status_tags.length - 3}
      </Badge>
    )}
  </div>
)}

{/* Carry Forward Indicator (only if tags exist and carry_forward is true) */}
{instance.status_tags && instance.status_tags.length > 0 && instance.carry_forward && (
  <div className="flex items-center gap-1 mt-1 text-[10px] text-muted-foreground">
    <Link2 className="w-3 h-3" />
    <span>Will carry forward</span>
  </div>
)}
```

**3.2 - Update Header to Show Tag Summary**

Update the panel header (around line 80):

```typescript
// Calculate tag statistics
const totalTags = assets.reduce((sum, a) => sum + (a.status_tags?.length ?? 0), 0);
const assetsWithTags = assets.filter(a => (a.status_tags?.length ?? 0) > 0).length;

// Update header subtext (around line 85):
<p className="text-sm text-muted-foreground">
  {assets.length} asset{assets.length !== 1 ? 's' : ''} • {' '}
  {assetsWithVisuals} with visuals • {' '}
  {assetsWithTags} with tags ({totalTags} total)
</p>
```

**Deliverable:**
- Tag chips displayed on each asset in the list (max 3 visible, +N for overflow)
- Carry-forward indicator icon when tags will persist
- Header statistics showing tag usage

---

### **Task 4: Tag-Based Filtering & Search**

**Goal:** Filter asset list by tags and search for specific tag names

**Files:**
- UPDATE: `src/components/pipeline/Stage8/SceneAssetListPanel.tsx`
- UPDATE: `src/components/pipeline/Stage8VisualDefinition.tsx` (pass filter state)

**Implementation:**

**4.1 - Add Filter State & UI**

Update `SceneAssetListPanel.tsx`:

```typescript
// Add imports
import { Search, Filter, X } from 'lucide-react';
import { Input } from '@/components/ui/input';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuCheckboxItem,
  DropdownMenuTrigger,
  DropdownMenuLabel,
  DropdownMenuSeparator,
} from '@/components/ui/dropdown-menu';

// Add props
export interface SceneAssetListPanelProps {
  // ... existing props
  onFilterChange?: (filters: AssetFilters) => void; // NEW
}

export interface AssetFilters {
  searchQuery: string;
  tagFilters: string[]; // Show only assets with these tags
  hasTagsOnly: boolean; // Show only assets with any tags
  carryForwardOnly: boolean; // Show only assets with carry_forward=true
}

// Add state (top of component)
const [filters, setFilters] = useState<AssetFilters>({
  searchQuery: '',
  tagFilters: [],
  hasTagsOnly: false,
  carryForwardOnly: false,
});

// Get all unique tags from all assets
const allTags = useMemo(() => {
  const tagSet = new Set<string>();
  assets.forEach(a => {
    (a.status_tags ?? []).forEach(tag => tagSet.add(tag));
  });
  return Array.from(tagSet).sort();
}, [assets]);

// Filter assets
const filteredAssets = useMemo(() => {
  let result = [...assets];
  
  // Search by name
  if (filters.searchQuery) {
    const q = filters.searchQuery.toLowerCase();
    result = result.filter(a => 
      a.project_asset?.name.toLowerCase().includes(q)
    );
  }
  
  // Filter by specific tags (AND logic)
  if (filters.tagFilters.length > 0) {
    result = result.filter(a => 
      filters.tagFilters.every(tag => 
        (a.status_tags ?? []).includes(tag)
      )
    );
  }
  
  // Filter: has any tags
  if (filters.hasTagsOnly) {
    result = result.filter(a => (a.status_tags?.length ?? 0) > 0);
  }
  
  // Filter: carry forward only
  if (filters.carryForwardOnly) {
    result = result.filter(a => a.carry_forward);
  }
  
  return result;
}, [assets, filters]);

// Update filter and notify parent
const updateFilters = (partial: Partial<AssetFilters>) => {
  const newFilters = { ...filters, ...partial };
  setFilters(newFilters);
  onFilterChange?.(newFilters);
};

// Add filter UI (after panel header, before asset groups):
<div className="space-y-2 px-4 pb-3 border-b border-border/50">
  {/* Search Input */}
  <div className="relative">
    <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-muted-foreground" />
    <Input
      placeholder="Search assets by name..."
      value={filters.searchQuery}
      onChange={e => updateFilters({ searchQuery: e.target.value })}
      className="pl-9 pr-9"
    />
    {filters.searchQuery && (
      <button
        className="absolute right-3 top-1/2 -translate-y-1/2 text-muted-foreground hover:text-foreground"
        onClick={() => updateFilters({ searchQuery: '' })}
      >
        <X className="w-4 h-4" />
      </button>
    )}
  </div>
  
  {/* Filter Dropdown */}
  <div className="flex items-center gap-2">
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="sm" className="gap-2">
          <Filter className="w-4 h-4" />
          <span>Filters</span>
          {(filters.tagFilters.length > 0 || filters.hasTagsOnly || filters.carryForwardOnly) && (
            <Badge variant="secondary" className="ml-1 px-1.5 py-0 h-4 text-[10px]">
              {filters.tagFilters.length + (filters.hasTagsOnly ? 1 : 0) + (filters.carryForwardOnly ? 1 : 0)}
            </Badge>
          )}
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="start" className="w-56">
        <DropdownMenuLabel>Filter by Status</DropdownMenuLabel>
        <DropdownMenuCheckboxItem
          checked={filters.hasTagsOnly}
          onCheckedChange={checked => updateFilters({ hasTagsOnly: checked })}
        >
          Has any tags
        </DropdownMenuCheckboxItem>
        <DropdownMenuCheckboxItem
          checked={filters.carryForwardOnly}
          onCheckedChange={checked => updateFilters({ carryForwardOnly: checked })}
        >
          Carry forward enabled
        </DropdownMenuCheckboxItem>
        
        {allTags.length > 0 && (
          <>
            <DropdownMenuSeparator />
            <DropdownMenuLabel>Filter by Tags</DropdownMenuLabel>
            {allTags.map(tag => (
              <DropdownMenuCheckboxItem
                key={tag}
                checked={filters.tagFilters.includes(tag)}
                onCheckedChange={checked => {
                  updateFilters({
                    tagFilters: checked
                      ? [...filters.tagFilters, tag]
                      : filters.tagFilters.filter(t => t !== tag)
                  });
                }}
              >
                {tag}
              </DropdownMenuCheckboxItem>
            ))}
          </>
        )}
      </DropdownMenuContent>
    </DropdownMenu>
    
    {/* Clear Filters */}
    {(filters.searchQuery || filters.tagFilters.length > 0 || filters.hasTagsOnly || filters.carryForwardOnly) && (
      <Button
        variant="ghost"
        size="sm"
        onClick={() => setFilters({
          searchQuery: '',
          tagFilters: [],
          hasTagsOnly: false,
          carryForwardOnly: false,
        })}
      >
        Clear all
      </Button>
    )}
  </div>
  
  {/* Active Filter Badges */}
  {filters.tagFilters.length > 0 && (
    <div className="flex flex-wrap gap-1">
      {filters.tagFilters.map(tag => {
        const colors = getTagColors(tag);
        return (
          <Badge
            key={tag}
            variant="secondary"
            className={cn('gap-1 pr-1 border', colors.bg, colors.text, colors.border)}
          >
            {tag}
            <button
              type="button"
              className="rounded-full p-0.5 hover:bg-muted transition-colors"
              onClick={() => updateFilters({
                tagFilters: filters.tagFilters.filter(t => t !== tag)
              })}
            >
              <X className="w-3 h-3" />
            </button>
          </Badge>
        );
      })}
    </div>
  )}
</div>
```

**4.2 - Use Filtered Assets**

Replace all `assets` references in the render with `filteredAssets`:

```typescript
// Update asset grouping (around line 140)
const groupedAssets = useMemo(() => {
  return {
    character: filteredAssets.filter(/* ... */),
    location: filteredAssets.filter(/* ... */),
    prop: filteredAssets.filter(/* ... */),
  };
}, [filteredAssets]);
```

**Deliverable:**
- Search input for asset names
- Filter dropdown with:
  - "Has any tags" checkbox
  - "Carry forward enabled" checkbox
  - Individual tag checkboxes (all unique tags)
- Active filter badges with remove buttons
- "Clear all" button
- Filtered asset list

---

### **Task 5: Tag Carry-Forward Prompt (New Scene Initialization)**

**Goal:** When entering a new scene, prompt user to carry forward tags from prior scene

**Hard copy logic:** When the user confirms carry-forward, the implementation creates or updates **new scene_asset_instance rows** for the current scene with the selected tags. Tags are stored as new data in the destination scene—no pointers or references to the prior scene. Modifying or removing a tag in a later scene (e.g. Scene 5) never retroactively changes an earlier scene (e.g. Scene 4).

**Scope:** This task covers **first-time scene entry** only (e.g. entering Stage 8 for Scene N and deciding which tags from Scene N−1 to apply). **Downstream invalidation** (e.g. editing tags in Scene 3 and then "Propagate to Scenes 4–10?") and bulk "Apply to all subsequent scenes" are deferred to Phase 10 (Feature 10.5: Invalidation Logic).

**Files:**
- NEW: `src/components/pipeline/Stage8/TagCarryForwardPrompt.tsx`
- UPDATE: `src/components/pipeline/Stage8VisualDefinition.tsx`
- UPDATE: `backend/src/services/assetInheritanceService.ts` (if needed)

**Implementation:**

**5.1 - Tag Carry-Forward Prompt Component**

Create `src/components/pipeline/Stage8/TagCarryForwardPrompt.tsx`:

```typescript
/**
 * Tag Carry-Forward Prompt (Feature 5.3, Task 5)
 * Shown when entering Stage 8 for a new scene to ask user about carrying forward tags
 * from prior scene instances.
 */

import { useState } from 'react';
import { Link2, AlertCircle, Check, X } from 'lucide-react';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Checkbox } from '@/components/ui/checkbox';
import { Label } from '@/components/ui/label';
import { ScrollArea } from '@/components/ui/scroll-area';
import { cn } from '@/lib/utils';
import { getTagColors } from '@/lib/constants/statusTags';
import type { SceneAssetInstance } from '@/types/scene';

export interface TagCarryForwardDecision {
  instanceId: string;
  assetName: string;
  tagsToCarry: string[];
  carryAll: boolean;
}

export interface TagCarryForwardPromptProps {
  isOpen: boolean;
  onClose: () => void;
  priorSceneNumber: number;
  currentSceneNumber: number;
  /** Instances from prior scene that have carry_forward=true and tags */
  priorInstances: Array<{
    instance: SceneAssetInstance;
    assetName: string;
  }>;
  onConfirm: (decisions: TagCarryForwardDecision[]) => void;
}

export function TagCarryForwardPrompt({
  isOpen,
  onClose,
  priorSceneNumber,
  currentSceneNumber,
  priorInstances,
  onConfirm,
}: TagCarryForwardPromptProps) {
  // Initialize all with carryAll=true (default behavior)
  const [decisions, setDecisions] = useState<Record<string, TagCarryForwardDecision>>(
    () => {
      const initial: Record<string, TagCarryForwardDecision> = {};
      priorInstances.forEach(({ instance, assetName }) => {
        initial[instance.id] = {
          instanceId: instance.id,
          assetName,
          tagsToCarry: [...(instance.status_tags ?? [])],
          carryAll: true,
        };
      });
      return initial;
    }
  );

  const handleToggleAll = (instanceId: string, carry: boolean) => {
    setDecisions(prev => ({
      ...prev,
      [instanceId]: {
        ...prev[instanceId],
        carryAll: carry,
        tagsToCarry: carry ? (priorInstances.find(p => p.instance.id === instanceId)?.instance.status_tags ?? []) : [],
      },
    }));
  };

  const handleToggleTag = (instanceId: string, tag: string) => {
    setDecisions(prev => {
      const current = prev[instanceId];
      const hasTag = current.tagsToCarry.includes(tag);
      const newTags = hasTag
        ? current.tagsToCarry.filter(t => t !== tag)
        : [...current.tagsToCarry, tag];
      
      const priorTags = priorInstances.find(p => p.instance.id === instanceId)?.instance.status_tags ?? [];
      const carryAll = newTags.length === priorTags.length;
      
      return {
        ...prev,
        [instanceId]: {
          ...current,
          tagsToCarry: newTags,
          carryAll,
        },
      };
    });
  };

  const handleConfirm = () => {
    onConfirm(Object.values(decisions));
    onClose();
  };

  const handleCarryAll = () => {
    const allDecisions: TagCarryForwardDecision[] = priorInstances.map(({ instance, assetName }) => ({
      instanceId: instance.id,
      assetName,
      tagsToCarry: [...(instance.status_tags ?? [])],
      carryAll: true,
    }));
    onConfirm(allDecisions);
    onClose();
  };

  const handleCarryNone = () => {
    const noneDecisions: TagCarryForwardDecision[] = priorInstances.map(({ instance, assetName }) => ({
      instanceId: instance.id,
      assetName,
      tagsToCarry: [],
      carryAll: false,
    }));
    onConfirm(noneDecisions);
    onClose();
  };

  const totalTags = priorInstances.reduce((sum, p) => sum + (p.instance.status_tags?.length ?? 0), 0);
  const selectedTags = Object.values(decisions).reduce((sum, d) => sum + d.tagsToCarry.length, 0);

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Link2 className="w-5 h-5 text-primary" />
            Carry Forward Status Tags from Scene {priorSceneNumber}?
          </DialogTitle>
          <DialogDescription>
            The following assets from Scene {priorSceneNumber} have status tags that can carry forward to Scene {currentSceneNumber}.
            Choose which tags to keep for continuity.
          </DialogDescription>
        </DialogHeader>

        <ScrollArea className="max-h-96 pr-4">
          <div className="space-y-4">
            {priorInstances.map(({ instance, assetName }) => {
              const decision = decisions[instance.id];
              const tags = instance.status_tags ?? [];
              
              return (
                <div key={instance.id} className="rounded-lg border border-border/50 bg-muted/30 p-4">
                  {/* Asset Header */}
                  <div className="flex items-start justify-between mb-3">
                    <div>
                      <h4 className="font-medium text-sm">{assetName}</h4>
                      <p className="text-xs text-muted-foreground">
                        {tags.length} tag{tags.length !== 1 ? 's' : ''}
                      </p>
                    </div>
                    <div className="flex items-center gap-2">
                      <Checkbox
                        id={`carry-all-${instance.id}`}
                        checked={decision.carryAll}
                        onCheckedChange={checked => handleToggleAll(instance.id, checked as boolean)}
                      />
                      <Label
                        htmlFor={`carry-all-${instance.id}`}
                        className="text-xs cursor-pointer"
                      >
                        Carry all
                      </Label>
                    </div>
                  </div>

                  {/* Tags */}
                  <div className="flex flex-wrap gap-2">
                    {tags.map(tag => {
                      const isSelected = decision.tagsToCarry.includes(tag);
                      const colors = getTagColors(tag);
                      
                      return (
                        <button
                          key={tag}
                          type="button"
                          onClick={() => handleToggleTag(instance.id, tag)}
                          className={cn(
                            'inline-flex items-center gap-1.5 rounded-full border px-3 py-1 text-xs font-semibold transition-all',
                            isSelected
                              ? cn(colors.bg, colors.text, colors.border, 'opacity-100')
                              : 'bg-muted/50 text-muted-foreground border-border/30 opacity-50 hover:opacity-75'
                          )}
                        >
                          {isSelected ? (
                            <Check className="w-3 h-3" />
                          ) : (
                            <X className="w-3 h-3" />
                          )}
                          {tag}
                        </button>
                      );
                    })}
                  </div>
                </div>
              );
            })}
          </div>
        </ScrollArea>

        <div className="flex items-center gap-2 rounded-lg border border-info/30 bg-info/10 p-3 text-sm">
          <AlertCircle className="w-4 h-4 text-info shrink-0" />
          <p className="text-info">
            Selected tags will be applied to the starting state of these assets in Scene {currentSceneNumber}.
            You can modify them later in the Visual State Editor.
          </p>
        </div>

        <div className="flex items-center justify-between text-sm text-muted-foreground">
          <span>
            {selectedTags} of {totalTags} tags selected
          </span>
        </div>

        <DialogFooter className="flex-col sm:flex-row gap-2">
          <Button variant="outline" onClick={handleCarryNone}>
            Carry None
          </Button>
          <Button variant="outline" onClick={handleCarryAll}>
            Carry All
          </Button>
          <Button onClick={handleConfirm}>
            Confirm Selection
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```

**5.2 - Integrate into Stage 8**

Update `Stage8VisualDefinition.tsx`:

```typescript
// Add imports
import { TagCarryForwardPrompt } from '@/components/pipeline/Stage8/TagCarryForwardPrompt';
import type { TagCarryForwardDecision } from '@/components/pipeline/Stage8/TagCarryForwardPrompt';

// Add state (after other state declarations)
const [showTagCarryForwardPrompt, setShowTagCarryForwardPrompt] = useState(false);
const [priorInstancesWithTags, setPriorInstancesWithTags] = useState<Array<{
  instance: SceneAssetInstance;
  assetName: string;
}>>([]);

// Add effect to detect prior scene tags (after sceneAssets query)
useEffect(() => {
  // Only check when we have assets and prior scene exists
  if (!sceneAssets || sceneAssets.length === 0 || !priorScene) return;
  
  // Check if any prior scene instances have carry_forward=true and tags
  // This requires fetching prior scene assets (add query)
  // For now, stub: show prompt if we detect inherited instances with tags
  
  const inheritedWithTags = sceneAssets.filter(a => 
    a.inherited_from_instance_id && 
    (a.status_tags?.length ?? 0) > 0
  );
  
  // If we have inherited instances with tags and user hasn't been prompted yet
  // (use localStorage or state to track if already shown for this scene)
  const promptKey = `tag-prompt-${sceneId}`;
  const alreadyPrompted = localStorage.getItem(promptKey);
  
  if (inheritedWithTags.length > 0 && !alreadyPrompted) {
    setPriorInstancesWithTags(
      inheritedWithTags.map(a => ({
        instance: a,
        assetName: a.project_asset?.name ?? 'Unknown',
      }))
    );
    setShowTagCarryForwardPrompt(true);
  }
}, [sceneAssets, priorScene, sceneId]);

// Add handler for tag carry-forward decisions
const handleTagCarryForwardConfirm = async (decisions: TagCarryForwardDecision[]) => {
  try {
    // Apply tag decisions to instances
    await Promise.all(
      decisions.map(decision => 
        sceneAssetService.updateSceneAsset(projectId, sceneId, decision.instanceId, {
          statusTags: decision.tagsToCarry,
          modificationReason: decision.carryAll
            ? `Carried forward all tags from prior scene`
            : decision.tagsToCarry.length === 0
            ? `Removed all tags from prior scene`
            : `Carried forward selected tags from prior scene`
        })
      )
    );
    
    // Mark as prompted
    localStorage.setItem(`tag-prompt-${sceneId}`, 'true');
    
    // Refetch assets
    refetch();
    
    toast.success('Tag carry-forward applied');
  } catch (error) {
    console.error('Tag carry-forward error:', error);
    toast.error('Failed to apply tag carry-forward');
  }
};

// Add modal to render (after other modals, before return)
<TagCarryForwardPrompt
  isOpen={showTagCarryForwardPrompt}
  onClose={() => {
    setShowTagCarryForwardPrompt(false);
    localStorage.setItem(`tag-prompt-${sceneId}`, 'true');
  }}
  priorSceneNumber={priorScene?.sceneNumber ?? 0}
  currentSceneNumber={currentScene?.sceneNumber ?? 0}
  priorInstances={priorInstancesWithTags}
  onConfirm={handleTagCarryForwardConfirm}
/>
```

**Note:** This implementation uses `localStorage` to track if the prompt has been shown for a scene. A more robust approach would:
- Query prior scene instances separately
- Store prompt state in the database
- Show prompt only on first entry to Stage 8 for a scene

**Deliverable:**
- Modal prompt showing assets with tags from prior scene
- Per-asset and per-tag selection checkboxes
- "Carry All", "Carry None", "Confirm Selection" actions
- Semantic tag colors in the prompt
- Automatic application of decisions via API

---

### **Task 6: Backend - Tag-Based Query Endpoint (Optional)**

**Goal:** Add optional query parameters to filter scene assets by tags

**Files:**
- UPDATE: `backend/src/routes/sceneAssets.ts`

**Implementation:**

Update the `GET /api/projects/:projectId/scenes/:sceneId/assets` endpoint:

```typescript
// Add query params validation
const QueryParamsSchema = z.object({
  tags: z.string().optional(), // Comma-separated tag names
  hasAnyTags: z.coerce.boolean().optional(),
  carryForward: z.coerce.boolean().optional(),
});

router.get('/:projectId/scenes/:sceneId/assets', async (req, res) => {
  try {
    const userId = req.user!.id;
    const { projectId, sceneId } = req.params;
    
    // Validate query params
    const queryValidation = QueryParamsSchema.safeParse(req.query);
    const queryParams = queryValidation.success ? queryValidation.data : {};

    // ... existing project/scene validation ...

    // Build query
    let query = supabase
      .from('scene_asset_instances')
      .select(`
        *,
        project_asset:project_assets(
          id, name, asset_type, description,
          image_key_url, visual_style_capsule_id
        )
      `)
      .eq('scene_id', sceneId)
      .order('created_at', { ascending: true });

    // Apply filters
    if (queryParams.carryForward !== undefined) {
      query = query.eq('carry_forward', queryParams.carryForward);
    }

    const { data: instances, error } = await query;

    if (error) {
      console.error('[SceneAssets] List error:', error);
      return res.status(500).json({ error: 'Failed to fetch scene assets' });
    }

    // Apply tag filters in memory (Supabase doesn't support array contains via REST)
    let filtered = instances || [];
    
    if (queryParams.tags) {
      const requiredTags = queryParams.tags.split(',').map(t => t.trim().toLowerCase());
      filtered = filtered.filter(inst => 
        requiredTags.every(tag => (inst.status_tags ?? []).includes(tag))
      );
    }
    
    if (queryParams.hasAnyTags) {
      filtered = filtered.filter(inst => (inst.status_tags ?? []).length > 0);
    }

    res.json(filtered);
  } catch (err) {
    console.error('[SceneAssets] List error:', err);
    res.status(500).json({ error: 'Internal server error' });
  }
});
```

**Frontend Service Update:**

Update `src/lib/services/sceneAssetService.ts`:

```typescript
async listSceneAssets(
  projectId: string,
  sceneId: string,
  filters?: {
    tags?: string[];
    hasAnyTags?: boolean;
    carryForward?: boolean;
  }
): Promise<SceneAssetInstance[]> {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session?.access_token) {
    throw new Error('User not authenticated');
  }

  // Build query params
  const params = new URLSearchParams();
  if (filters?.tags && filters.tags.length > 0) {
    params.append('tags', filters.tags.join(','));
  }
  if (filters?.hasAnyTags !== undefined) {
    params.append('hasAnyTags', String(filters.hasAnyTags));
  }
  if (filters?.carryForward !== undefined) {
    params.append('carryForward', String(filters.carryForward));
  }

  const queryString = params.toString();
  const url = `/api/projects/${projectId}/scenes/${sceneId}/assets${queryString ? `?${queryString}` : ''}`;

  const response = await fetch(url, {
    headers: {
      'Authorization': `Bearer ${session.access_token}`,
    },
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error || 'Failed to fetch scene assets');
  }

  return response.json();
}
```

**Decision Point:** This is **optional** because:
- Frontend filtering (Task 4) handles most use cases
- Backend filtering is more efficient for large datasets
- Recommend implementing if performance becomes an issue

**Deliverable:**
- Query parameters: `?tags=muddy,torn&hasAnyTags=true&carryForward=true`
- Backend filtering with in-memory tag matching
- Updated service method with filter support

---

### **Task 7: Tag Evolution Tracking (Optional Enhancement)**

**Goal:** Track how tags change across scenes for a given asset (timeline view)

**Stage 10 consumption:** When Stage 10 (Frame/Video generation) is implemented, it must consume `status_tags` as the source of truth for visual state—e.g. a `getAssetVisualDescription(instanceId)` that concatenates `effective_description` with active tags for prompt injection. That implementation is Stage 10 scope; 5.3 only ensures tags are stored and editable.

**Files:**
- NEW: `src/components/pipeline/Stage8/TagEvolutionTimeline.tsx`
- UPDATE: `src/components/pipeline/Stage8/VisualStateEditorPanel.tsx` (add timeline button)
- NEW: Backend query to fetch asset instance chain

**Implementation:**

This is an **advanced feature** for future enhancement. It would:
1. Query the inheritance chain for an asset (`inherited_from_instance_id` links)
2. Display tag changes across scenes as a timeline
3. Show when tags were added/removed/carried forward

**Example UI:**
```
Scene 1: [clean]
Scene 3: [clean, muddy] ← added "muddy"
Scene 5: [muddy] ← removed "clean"
Scene 7: [muddy, torn] ← added "torn"
```

**Recommendation:** Defer to Phase 5.4 (Asset State Evolution) or Phase 10+ (advanced features).

---

## TESTING STRATEGY

### Manual Testing Checklist

**Test 1: Tag Creation & Categorization**
- [ ] Add tags in StatusTagsEditor
- [ ] Verify predefined tags show correct colors (muddy=amber, torn=red, wet=blue, clean=green)
- [ ] Add custom tag, verify it shows default gray color
- [ ] Verify tags are lowercase normalized

**Test 2: Tag Autocomplete**
- [ ] Type "mu" in tag input, verify "muddy" appears in suggestions
- [ ] Select suggestion, verify tag is added
- [ ] Type "custom_tag", verify no suggestions appear but can still add

**Test 3: Tag Display in Asset List**
- [ ] Open Stage 8 with scene that has tagged assets
- [ ] Verify tags show as colored chips on each asset card
- [ ] Verify max 3 tags visible with "+N" overflow badge
- [ ] Verify "Will carry forward" indicator shows when carry_forward=true

**Test 4: Tag Filtering**
- [ ] Open filter dropdown in asset list
- [ ] Check "Has any tags" - verify only tagged assets show
- [ ] Check specific tag (e.g. "muddy") - verify only assets with that tag show
- [ ] Check multiple tags - verify AND logic (only assets with ALL selected tags)
- [ ] Verify active filter badges show below filter button
- [ ] Click "Clear all" - verify all filters reset

**Test 5: Tag Search**
- [ ] Type asset name in search input
- [ ] Verify filtered assets show
- [ ] Combine search with tag filters
- [ ] Verify both filters apply (AND logic)

**Test 6: Carry-Forward Prompt**
- [ ] Create Scene 1, add asset, add tags, set carry_forward=true
- [ ] Lock shot list for Scene 1
- [ ] Enter Stage 8 for Scene 2
- [ ] Verify carry-forward prompt shows with Scene 1 assets
- [ ] Toggle individual tags on/off
- [ ] Click "Carry All" - verify all tags applied
- [ ] Close and reopen Stage 8 for Scene 2 - verify prompt doesn't show again

**Test 7: Tag Persistence**
- [ ] Edit tags in Visual State Editor
- [ ] Toggle carry_forward switch
- [ ] Save changes
- [ ] Reload page - verify tags and carry_forward persist
- [ ] Check database - verify `status_tags` and `carry_forward` columns updated

**Test 8: Validation Trigger (if Task 1 implemented)**
- [ ] Try to add tags to asset in scene with status='draft' (before Stage 7)
- [ ] Verify error toast shows
- [ ] Lock shot list (Stage 7)
- [ ] Try to add tags again - verify success

### Automated Testing (Optional)

**Backend Unit Tests:**
```typescript
// backend/tests/statusTags.test.ts
describe('Status Tags API', () => {
  it('should create instance with tags', async () => {
    // POST with statusTags array
  });
  
  it('should update instance tags', async () => {
    // PUT with statusTags
  });
  
  it('should filter instances by tags', async () => {
    // GET with ?tags=muddy,torn
  });
  
  it('should validate tags only after Stage 7', async () => {
    // POST with tags to draft scene (should fail)
  });
});
```

**Frontend Component Tests:**
```typescript
// src/components/pipeline/Stage8/StatusTagsEditor.test.tsx
describe('StatusTagsEditor', () => {
  it('renders tags with correct colors', () => {
    // Test category colors
  });
  
  it('shows autocomplete suggestions', () => {
    // Test suggestion dropdown
  });
  
  it('toggles carry forward', () => {
    // Test switch
  });
});
```

---

## DELIVERABLES SUMMARY

### Migration Files
1. ✅ (Optional) `backend/migrations/018_status_tags_validation.sql` - Validation trigger

### Backend Files
2. ✅ (Optional) `backend/src/routes/sceneAssets.ts` - Query param filtering (Task 6)

### Frontend Library Files
3. ✅ `src/lib/constants/statusTags.ts` - Tag categories, colors, suggestions (Task 2)

### Frontend Component Files
4. ✅ `src/components/pipeline/Stage8/StatusTagsEditor.tsx` - Add autocomplete & colors (Task 2)
5. ✅ `src/components/pipeline/Stage8/SceneAssetListPanel.tsx` - Tag display & filtering (Tasks 3 & 4)
6. ✅ `src/components/pipeline/Stage8/TagCarryForwardPrompt.tsx` - NEW carry-forward modal (Task 5)
7. ✅ `src/components/pipeline/Stage8VisualDefinition.tsx` - Integrate prompt (Task 5)

### Documentation Updates
8. ✅ This development plan (`._docs/5.3-dev-plan.md`)

---

## IMPLEMENTATION ORDER

**Recommended sequence:**

1. **Task 2** (Tag Categories) - Foundation for all tag UI
2. **Task 3** (Tag Display) - Visual feedback in asset list
3. **Task 4** (Filtering) - Search and filter functionality
4. **Task 5** (Carry-Forward Prompt) - Continuity workflow
5. **Task 1** (Validation Trigger) - Optional database safety
6. **Task 6** (Backend Filtering) - Optional performance optimization
7. **Task 7** (Evolution Tracking) - Future enhancement

**Estimated effort:**
- Task 1: 30 minutes (migration only)
- Task 2: 2-3 hours (categories + autocomplete)
- Task 3: 1-2 hours (display chips)
- Task 4: 3-4 hours (filtering UI + logic)
- Task 5: 4-5 hours (complex modal + integration)
- Task 6: 1-2 hours (optional backend)
- Task 7: 6-8 hours (future enhancement)

**Total: 11-16 hours** (excluding Task 7)

---

## INTEGRATION POINTS

### With Feature 5.1 (Scene Asset Instances)
- Uses existing `status_tags` and `carry_forward` columns
- Uses existing CRUD routes
- Uses existing `AssetInheritanceService` for prior scene detection

### With Feature 5.2 (Stage 8 UI)
- Extends `SceneAssetListPanel` with tag display and filters
- Uses existing `StatusTagsEditor` component (enhances with autocomplete)
- Uses existing `VisualStateEditorPanel` (no changes needed)
- Integrates into `Stage8VisualDefinition` main component

### With Feature 5.4 (Asset State Evolution)
- Tag evolution timeline (Task 7) is a bridge to 5.4
- Tag history tracking will feed into asset timeline view

### With Feature 5.5 (Scene-to-Scene Continuity)
- Carry-forward prompt is the primary continuity enforcement
- Tags are key metadata for visual consistency checks

---

## USER FLOWS

### Flow 1: First-Time Tag Addition
1. User enters Stage 8 for Scene 1
2. User selects asset from list
3. User sees Visual State Editor with StatusTagsEditor
4. User types "mu" in tag input
5. Autocomplete shows "muddy"
6. User selects "muddy" - tag appears as amber chip
7. User toggles "Carry forward to next scene" (default ON)
8. Tag saves automatically on blur

### Flow 2: Tag Carry-Forward (New Scene)
1. User completes Scene 1 with tagged assets
2. User enters Stage 8 for Scene 2
3. **Tag Carry-Forward Prompt** appears showing Scene 1 assets with tags
4. User reviews each asset:
   - Character "John" has tags: [muddy, torn]
   - User unchecks "torn" (it was fixed between scenes)
   - User keeps "muddy" checked
5. User clicks "Confirm Selection"
6. Scene 2 assets are created with selected tags
7. User sees assets in list with tags

### Flow 3: Tag Filtering
1. User has 20 assets in Stage 8
2. User wants to find all "bloody" assets
3. User clicks "Filters" dropdown
4. User checks "bloody" tag
5. Asset list filters to 3 assets with "bloody" tag
6. User generates images for these 3 assets (bulk select)
7. User clears filter to see all assets again

---

## EDGE CASES & ERROR HANDLING

### Edge Case 1: No Prior Scene
- **Scenario:** Scene 1 has no prior scene
- **Handling:** Don't show carry-forward prompt (no prior instances to inherit from)

### Edge Case 2: Prior Scene Has No Tags
- **Scenario:** Prior scene assets have no tags (empty arrays)
- **Handling:** Don't show carry-forward prompt (nothing to carry forward)

### Edge Case 3: Carry-Forward Disabled
- **Scenario:** Prior scene asset has tags but `carry_forward=false`
- **Handling:** Don't include this asset in carry-forward prompt

### Edge Case 4: Tag Before Stage 7 Complete
- **Scenario:** User tries to add tags when scene status is 'draft'
- **Handling:**
  - If validation trigger (Task 1) implemented: Database rejects, show error toast
  - If not: Allow tags but warn user that Stage 8 requires Stage 7 completion

### Edge Case 5: Filter with No Results
- **Scenario:** User selects tag filter that matches zero assets
- **Handling:** Show empty state: "No assets match the selected filters. Clear filters to see all assets."

### Edge Case 6: Autocomplete Ambiguity
- **Scenario:** User types "torn" - could match "torn", "torn_shirt", "torn_jacket"
- **Handling:** Show all matching suggestions; user can add custom if desired

### Edge Case 7: Tag Case Sensitivity
- **Scenario:** User adds "Muddy" but system has "muddy"
- **Handling:** Normalize to lowercase on input; prevent duplicates

### Edge Case 8: Editing Tags in a Middle Scene (Non-Linear Workflow)
- **Scenario:** User defines tags for Scene 10, then goes back and changes tags in Scene 3.
- **Handling (5.3):** Scene 3's row is updated; Scene 10 is unchanged (hard copy). No automatic "Propagate changes downstream?" prompt in 5.3.
- **Deferred to Phase 10:** Downstream invalidation and "Apply to all subsequent scenes" bulk action (Feature 10.5: Invalidation Logic).

---

## FUTURE ENHANCEMENTS (Post-5.3)

1. **Tag Templates** - Predefined tag sets for common scenarios (e.g. "Fight Scene" = [bloody, torn, sweaty])
2. **Tag History** - View when tags were added/removed across scenes (Task 7)
3. **Bulk Tag Operations** - Add/remove tags for multiple assets at once
4. **Tag Search in Global Assets** - Filter project assets by tags in Asset Drawer
5. **Tag-Based Prompt Injection** - Automatically enhance image prompts based on tags (e.g. "muddy" → "covered in mud, dirty, realistic grime")
6. **Tag Severity Levels** - "light muddy" vs "heavy muddy" for granular control
7. **Tag Conflict Detection** - Warn if incompatible tags applied (e.g. "clean" + "muddy")
8. **Tag Analytics** - Dashboard showing tag usage across project

---

## REFERENCES

### Documentation
- `._docs/implementation-task-list.md` (lines 266-311) - Feature 5.3 requirements
- `._docs/database-schema-state-transition-matrix.md` (lines 603-631, 866-880, 1111-1131) - Schema + validation trigger
- `._docs/project-overview.md` (lines 103-112, 212-221, 589-638) - PRD for Stage 8 and stateful assets
- `._docs/ui-and-theme-rules.md` - Color palette for tag categories
- `._docs/5.1-dev-plan.md` (lines 1658-1806) - Implementation summary for Feature 5.1
- `._docs/5.2-dev-plan-v1.md` (lines 1297-1570) - Implementation summary for Feature 5.2

### Codebase
- `backend/migrations/015_scene_asset_instances.sql` - Table schema
- `backend/src/routes/sceneAssets.ts` - CRUD routes
- `src/types/scene.ts` - Type definitions
- `src/lib/services/sceneAssetService.ts` - API service
- `src/components/pipeline/Stage8/StatusTagsEditor.tsx` - Existing tag editor
- `src/components/pipeline/Stage8/SceneAssetListPanel.tsx` - Asset list panel
- `src/components/pipeline/Stage8VisualDefinition.tsx` - Stage 8 main component
- `src/components/ui/badge.tsx` - shadcn Badge component

---

## NOTES FOR IMPLEMENTATION

### Design Decisions

1. **Why category-based colors?**
   - Provides visual differentiation (condition vs damage vs temporal)
   - Helps users quickly identify tag types
   - Aligns with ui-and-theme-rules.md color system

2. **Why autocomplete?**
   - Reduces typos and inconsistencies
   - Encourages use of predefined common tags
   - Doesn't prevent custom tags (power users can still add any tag)

3. **Why carry-forward prompt?**
   - Makes continuity decision explicit (no silent defaults)
   - Gives user control over which tags persist
   - Prevents tag bloat (user can clear irrelevant tags)

4. **Why Task 1 (validation trigger) is optional?**
   - Frontend already gates Stage 8 by scene status
   - Adds complexity to testing (need to mock scene status)
   - Database-level validation is a "nice to have" for data integrity

5. **Why Task 6 (backend filtering) is optional?**
   - Frontend filtering is fast for typical dataset sizes (<1000 assets per scene)
   - Backend filtering requires Supabase functions or RPC (not available in REST API for array contains)
   - Implement only if performance testing shows frontend filtering is slow

### Code Style Notes

- Use semantic color variables from `ui-and-theme-rules.md` (e.g. `text-amber-400`, not hex codes)
- Follow existing Stage 8 component patterns (SceneAssetListPanel, VisualStateEditorPanel)
- Use `cn()` utility for conditional classes
- Prefer `useMemo` for expensive filters/computations
- Use React Query mutations with cache invalidation for persistence
- All tag names normalized to lowercase for consistency

### Performance Considerations

- Tag filtering runs in-memory on frontend (O(n) per filter)
- Autocomplete debounced to avoid excessive re-renders
- Tag color lookup uses Map for O(1) access
- Carry-forward prompt lazy-loaded (only shown when needed)

---

## CONCLUSION

Feature 5.3 (Status Metadata Tags) builds on the existing scene asset instance system (5.1) and Stage 8 UI (5.2) to provide comprehensive tag management with:

1. **Visual differentiation** via category-based colors
2. **Efficient discovery** via autocomplete (predefined + project-used tags prioritized) and filtering
3. **Continuity enforcement** via carry-forward prompts (hard copy per scene; no pointers)
4. **Branch-scoped persistence:** tags live in `scene_asset_instances` per scene, and scenes belong to `active_branch_id`—so tags in Branch B do not affect Branch A; merge and conflict UI are deferred to Phase 10
5. **Database safety** via optional validation trigger

The implementation is modular and incremental:
- Core functionality (Tasks 2-5) is **required**
- Database validation (Task 1) is **optional but recommended**
- Backend filtering (Task 6) is **optional for performance**
- Evolution tracking (Task 7) is **future enhancement**

Total effort: **11-16 hours** for required features, with clear user benefits at each task completion.

---

**END OF DEVELOPMENT PLAN**


# **IMPLEMENTATION SUMMARIES**:

## Summary of what was implemented for **Task 2: Tag Category System & Semantic Styling**:

### 2.1 – Tag categories constant

**Created** `src/lib/constants/statusTags.ts` with:

- **`StatusTagCategory`** – `'condition' | 'damage' | 'temporal' | 'appearance' | 'custom'`
- **`StatusTagDefinition`** – `name`, `category`, optional `description`
- **`COMMON_STATUS_TAGS`** – 18 predefined tags (5 condition, 5 damage, 4 temporal, 4 appearance)
- **`TAG_CATEGORY_COLORS`** – Tailwind classes per category (condition=amber, damage=destructive, temporal=info, appearance=success, custom=secondary)
- **`getTagCategory(tagName)`** – returns category or `'custom'`
- **`getTagColors(tagName)`** – returns `{ bg, text, border }` classes
- **`getTagSuggestions(query, projectTags?)`** – up to 8 suggestions; when `projectTags` is passed, project-used tags are listed first

### 2.2 – StatusTagsEditor category colors

- Imported **`getTagColors`** and **`getTagSuggestions`** from `@/lib/constants/statusTags`.
- Badges now use **`getTagColors(tag)`** and apply `colors.bg`, `colors.text`, `colors.border` via `cn(...)` so each tag shows its category color.

### 2.3 – Autocomplete in StatusTagsEditor

- **Props:** added optional **`projectTags?: string[]`** for project/branch tags to prioritize in suggestions.
- **State:** `suggestions`, `showSuggestions` (in addition to existing `inputValue`).
- **Handlers:** `handleAddTag(tag?)` (adds from argument or input, clears suggestions); **`handleInputChange(value)`** updates input and calls `getTagSuggestions(value, projectTags)`.
- **Input:** controlled by `inputValue`; `onChange` → `handleInputChange`; Enter adds tag; Escape closes suggestions; focus/blur with 200ms delay so suggestion clicks register.
- **Dropdown:** absolute-positioned list under the input when `showSuggestions && suggestions.length > 0`; clicking a suggestion adds that tag.

**Deliverables:**

- Tag category system with semantic colors (condition=amber, damage=red, temporal=blue, appearance=green, custom=secondary).
- Autocomplete in StatusTagsEditor (predefined + project-used tags when `projectTags` is passed).
- 18 predefined common tags.

Callers can pass `projectTags` (e.g. from scene assets or `listSceneAssets` for the branch) so the dropdown favors already-used tags and keeps naming consistent. Lint is clean for both files.

## Summary of what was implemented for **Task 3: Tag Display in Asset List Panel**:

### 3.1 – Tag display on asset list items

- **Imports:** `getTagColors` from `@/lib/constants/statusTags` and `Link2` from `lucide-react`.
- **In each asset card (inside `AssetTypeGroup`):**
  - **Status tags:** Up to 3 tags shown as small badges using `getTagColors(tag)` for category colors (condition/damage/temporal/appearance/custom). If there are more than 3 tags, a “+N” badge is shown.
  - **Carry-forward:** When the instance has at least one tag and `carry_forward` is true, a line with the Link2 icon and “Will carry forward” is shown below the tags.

### 3.2 – Header tag summary

- **Computed values:** `totalTags` (sum of all tag counts) and `assetsWithTags` (number of assets with at least one tag).
- **Header subtext:** Updated from  
  `X assets • Y with visuals`  
  to  
  `X asset(s) • Y with visuals • Z with tags (W total)`  
  with correct “asset” vs “assets” and the new tag stats.

**Deliverables (per plan):**

- Tag chips on each asset (max 3 visible, +N for overflow), using semantic colors from `statusTags`.
- Carry-forward line with Link2 when tags exist and `carry_forward` is true.
- Header shows tag usage: “X with tags (Y total)”.

No new linter issues were reported. The panel now shows status tags and carry-forward in the list and summarizes tag usage in the header.

-----

## Summary of what was implemented for **Task 4: Tag-Based Filtering & Search**:

### 1. **SceneAssetListPanel.tsx**

- **`AssetFilters` interface**  
  - `searchQuery`, `tagFilters`, `hasTagsOnly`, `carryForwardOnly`.

- **Props**  
  - `onFilterChange?: (filters: AssetFilters) => void` added.

- **State and derived data**  
  - Local `filters` state with default values.  
  - `allTags`: unique tags from all assets (sorted).  
  - `filteredAssets`: assets after applying search, tag filters (AND), “Has any tags”, and “Carry forward enabled”.  
  - `updateFilters(partial)` and `clearFilters()` that call `onFilterChange` when filters change.

- **Filter UI (below panel header)**  
  - **Search**: input with Search icon and clear (X) when non-empty; filters by asset name.  
  - **Filters dropdown**: “Has any tags”, “Carry forward enabled”, then “Filter by Tags” with a checkbox per tag (only if there are tags). Badge on trigger shows active filter count.  
  - **Clear all**: visible when any filter is active; resets all filters and notifies parent.  
  - **Active tag filters**: badges for each selected tag (using `getTagColors`), each with an X to remove that tag from `tagFilters`.

- **Use of filtered list**  
  - `groupedAssets` is computed from `filteredAssets`.  
  - Header line shows count and stats (with visuals, with tags, total tags) for **filtered** assets.

### 2. **Stage8VisualDefinition.tsx**

- **Filter state**  
  - `assetFilters` state (optional, for future use e.g. URL sync).  
  - `SceneAssetListPanel` receives `onFilterChange={setAssetFilters}` so the parent receives current filters whenever they change.

**Deliverables (per plan):**

- Search input for asset names.  
- Filter dropdown: “Has any tags”, “Carry forward enabled”, and per-tag checkboxes.  
- Active filter badges with remove (X).  
- “Clear all” button.  
- List and header stats driven by filtered assets.  
- Filter state passed to parent via `onFilterChange`.