# **Feature 5.2: Stage 8 - Visual Definition UI - Implementation Plan**

*This plan has been revised to incorporate recommendations from 5.2-plan-revision-recs.md. Revisions are summarized in the "Revisions Applied" section below.*

---

## **Executive Summary**

This plan details the implementation of Stage 8's complete UI/UX system for defining scene starting visual states. Stage 8 is where users assemble, review, modify, and generate visual references for all assets appearing in a scene. The current implementation uses mock data and a simplified three-panel layout. This plan will replace it with a production-ready system that:

1. **Integrates with Feature 5.1's scene asset instance infrastructure** (already implemented)
2. **Provides asset relevance detection** (AI agent determines which assets are needed)
3. **Enables scene-specific visual state editing** with inheritance from prior scenes
4. **Supports bulk scene asset image generation** with Nano Banana
5. **Integrates the Asset Drawer** for adding assets from global/project libraries

---

## **Architecture Overview**

### **Data Flow**
```
Stage 7 (Shot List) → Stage 8 Entry
    ↓
1. Load Scene Asset Instances (GET /api/projects/:projectId/scenes/:sceneId/assets)
    - Returns existing instances if scene was visited before
    - Returns empty array if first visit
    ↓
2. Trigger Asset Relevance Detection (AI Agent - if no instances exist)
    - Analyzes shot list to determine which assets are needed
    - Returns relevant_assets[] and new_assets_required[]
    ↓
3. User Reviews & Edits Asset Descriptions
    - Scene Visual Elements Panel: grouped list of assets
    - Visual State Editor: modify effective_description
    - Asset Drawer: add missing assets or create new ones
    ↓
4. Bulk Image Generation (Multi-select + Generate button)
    - POST /api/projects/:projectId/scenes/:sceneId/assets/:instanceId/generate-image
    - Uses effective_description + locked visual style capsule
    - Polls for job completion
    ↓
5. Lock & Proceed to Stage 9
```

### **Key Constraints (from PRD)**
- **Stage 8 defines ONLY starting visual conditions** (not mid-scene changes)
- **Inheritance logic**: Scene 1 inherits from Master Assets; Scene N inherits from prior scene(s) end states (see Revisions: non-linear inheritance)
- **Status tags** (e.g., "muddy", "torn") carry forward between scenes if `carry_forward: true` (instance-level; per-tag optional future)
- **Modification tracking**: audit trail for description changes (`modification_count`, `last_modified_field`, `modification_reason`)

---

## **Revisions Applied (from 5.2-plan-revision-recs.md)**

The following revisions were adopted after critical review against the codebase and PRD:

| Revision | Decision | Rationale |
|----------|----------|-----------|
| **Non-linear inheritance** | **Adopted** | If an asset skips a scene (e.g. in Scene 1, absent in 2, in 3), inheritance should use the *most recent* instance of that asset in the branch, not strictly N−1. Relevance agent and inheritance context updated accordingly. |
| **AI asset "hallucination"** | **Adopted** | Relevance agent must only output `relevant_assets` that reference *existing* `project_asset_id`. `new_assets_required` is advisory only; never auto-create project assets or scene instances from it. UI shows suggestions with "Add from library" / "Ignore". |
| **Cost discipline** | **Adopted** | PRD requires cost awareness. Add cost preview (count × cost per image) and a confirmation modal before bulk image generation. |
| **UI layout (split-view)** | **Partially adopted** | PRD specifies: Scene Visual Elements (left), Visual State Editor (center), Asset Drawer (right); Rearview Mirror at *top* (Phase B). Plan keeps three-panel layout; adds **Continuity Header / Rearview Mirror** at top and **inheritance path + previous scene end-state** in the editor or continuity panel. |
| **Per-tag carry_forward** | **Deferred** | Current schema has single `carry_forward` per instance. Per-tag "sticky" would require schema change. Plan keeps instance-level carry_forward with clear UI; per-tag toggle documented as future enhancement. |
| **Continuity conflict detection** | **Optional / future** | "Reconcile" flow (e.g. prior scene "Exploded" vs current script "Drives away") noted as optional; implement if time permits or as follow-up. |
| **React Query** | **Adopted** | Use React Query (`useQuery` / `useMutation`) for scene asset list and mutations to align with existing tech stack. |

---

## **Task Breakdown**

### **Task 1: Backend - Scene Asset Relevance Agent (AI)**

**Purpose**: Automatically detect which assets are needed for a scene based on the locked shot list. **Revisions:** (1) Inheritance context uses *most recent instance per asset* in the branch (non-linear), not only N−1. (2) Only existing project assets may be suggested; `new_assets_required` is advisory only—never auto-create.

**Files to Create/Modify**:
- `backend/src/services/sceneAssetRelevanceService.ts` (new)
- `backend/src/services/assetInheritanceService.ts` (optional: add helper `getLastInstancePerAsset(branchId, sceneId)` for "search backwards")
- `backend/src/routes/sceneAssets.ts` (add relevance endpoint)

**Implementation Steps**:

#### **1.1 Create SceneAssetRelevanceService**

**Non-linear inheritance context:** Instead of querying only `scene_number - 1`, build a "last appearance per asset" map: for each locked project asset, find the most recent scene (in the same branch, scene_number < current) that has a `scene_asset_instance` for that `project_asset_id`. Use that instance's state (effective_description, status_tags, carry_forward) as the inheritance context for the AI. This preserves continuity when an asset skips scenes (e.g. in Scene 1, absent in 2, in 3).

**Business rule – no asset hallucination:** The AI must only output `relevant_assets` whose `project_asset_id` exists in the provided "AVAILABLE PROJECT ASSETS" list. It must *not* invent UUIDs. `new_assets_required` is for assets mentioned in the shot list but not in the project library; these are advisory only. The backend must validate that every `relevant_assets[].project_asset_id` is in the project's locked assets before creating any scene instances. Never create project_assets or scene_asset_instances from `new_assets_required` automatically.

```typescript
// backend/src/services/sceneAssetRelevanceService.ts
import { supabase } from '../config/supabase.js';
import { AnthropicClient } from '../services/ai/anthropicClient.js'; // Or OpenAI – use existing LLM integration
import type { SceneAssetRelevanceResult } from '../../types/scene.js';

export class SceneAssetRelevanceService {
  private aiClient: AnthropicClient;

  constructor() {
    this.aiClient = new AnthropicClient();
  }

  /**
   * Get the most recent instance of each project asset in prior scenes (same branch).
   * Used for non-linear inheritance: if an asset skips a scene, we inherit from its last appearance.
   */
  private async getLastInstancePerAsset(
    branchId: string,
    currentSceneNumber: number
  ): Promise<Map<string, { scene_number: number; effective_description: string; status_tags: string[]; inherited_from_instance_id: string | null }>> {
    const { data: priorScenes } = await supabase
      .from('scenes')
      .select('id, scene_number')
      .eq('branch_id', branchId)
      .lt('scene_number', currentSceneNumber)
      .order('scene_number', { ascending: false });

    if (!priorScenes?.length) return new Map();

    const sceneIds = priorScenes.map((s) => s.id);
    const { data: instances } = await supabase
      .from('scene_asset_instances')
      .select(`
        project_asset_id,
        effective_description,
        status_tags,
        inherited_from_instance_id,
        scene_id
      `)
      .in('scene_id', sceneIds);

    const byAsset = new Map<string, { scene_number: number; effective_description: string; status_tags: string[]; inherited_from_instance_id: string | null }>();
    const sceneNumberById = new Map(priorScenes.map((s) => [s.id, s.scene_number]));
    for (const inst of instances ?? []) {
      if (!byAsset.has(inst.project_asset_id)) {
        const sceneNumber = sceneNumberById.get(inst.scene_id) ?? 0;
        byAsset.set(inst.project_asset_id, {
          scene_number: sceneNumber,
          effective_description: inst.effective_description ?? '',
          status_tags: inst.status_tags ?? [],
          inherited_from_instance_id: inst.inherited_from_instance_id ?? null,
        });
      }
    }
    return byAsset;
  }

  /**
   * Analyze shot list to determine which project assets are relevant.
   * Adheres to AI-agent-registry-context-flow-architecture.md (lines 668-750).
   * Revisions: non-linear inheritance context; project-asset-only output.
   */
  async detectRelevantAssets(
    sceneId: string,
    branchId: string
  ): Promise<SceneAssetRelevanceResult> {
    const { data: scene, error: sceneErr } = await supabase
      .from('scenes')
      .select('id, scene_number, script_excerpt')
      .eq('id', sceneId)
      .single();
    if (sceneErr || !scene) throw new Error('Scene not found');

    const { data: shots } = await supabase
      .from('shots')
      .select('shot_id, characters_foreground, characters_background, setting, action')
      .eq('scene_id', sceneId)
      .order('shot_order');

    // Non-linear: last instance per asset across all prior scenes in branch
    const lastInstancePerAsset = await this.getLastInstancePerAsset(branchId, scene.scene_number);

    const { data: projectAssets } = await supabase
      .from('project_assets')
      .select('id, name, asset_type, description, image_key_url')
      .eq('branch_id', branchId)
      .eq('locked', true);

    const prompt = this.buildRelevancePrompt(scene, shots ?? [], lastInstancePerAsset, projectAssets ?? []);
    const aiResponse = await this.aiClient.complete(prompt);
    const raw = this.parseRelevanceResponse(aiResponse);

    // Validate: every relevant_assets[].project_asset_id must exist in project
    const validIds = new Set((projectAssets ?? []).map((a) => a.id));
    const relevant_assets = (raw.relevant_assets ?? []).filter((ra) => validIds.has(ra.project_asset_id));
    return { ...raw, relevant_assets };
  }

  private buildRelevancePrompt(
    scene: { id: string; scene_number: number; script_excerpt: string },
    shots: Array<{ shot_id: string; characters_foreground: string[]; characters_background: string[]; setting: string; action: string }>,
    lastInstancePerAsset: Map<string, { scene_number: number; effective_description: string; status_tags: string[]; inherited_from_instance_id: string | null }>,
    projectAssets: Array<{ id: string; name: string; asset_type: string; description: string; image_key_url?: string | null }>
  ): string {
    const inheritanceContext = Array.from(lastInstancePerAsset.entries()).map(
      ([project_asset_id, state]) =>
        `project_asset_id ${project_asset_id}: last in scene ${state.scene_number}, description: ${state.effective_description}, status_tags: ${state.status_tags.join(', ') || 'none'}`
    );

    return `
You are an asset continuity manager. Determine which **existing** Master Assets (from the list below) appear in the current scene and their starting visual state.

CRITICAL: You may ONLY reference project_asset_id values that appear in "AVAILABLE PROJECT ASSETS". Do not invent IDs. If the shot list mentions something not in that list, put it in "new_assets_required" only (advisory; no IDs).

CURRENT SCENE:
Scene Number: ${scene.scene_number}
Script Excerpt: ${scene.script_excerpt}

Shot List:
${shots.map((s) => `- Shot ${s.shot_id}: Characters: ${(s.characters_foreground || []).join(', ')}; Setting: ${s.setting}; Action: ${s.action}`).join('\n')}

LAST KNOWN STATE PER ASSET (most recent prior appearance in this branch):
${inheritanceContext.length ? inheritanceContext.join('\n') : 'None (Scene 1)'}

AVAILABLE PROJECT ASSETS (only these may appear in relevant_assets):
${projectAssets.map((a) => `- id: ${a.id}, name: ${a.name}, type: ${a.asset_type}, description: ${a.description}`).join('\n')}

RELEVANCE RULES:
1. Include only characters/props/settings explicitly or clearly implied in the shot list.
2. For each asset, use LAST KNOWN STATE if present; otherwise use Master Asset description.
3. relevant_assets[].project_asset_id MUST be one of the AVAILABLE PROJECT ASSETS ids.

STATE INHERITANCE:
- If the asset has a "last known state" above, use that as starting_description and status_tags_inherited.
- If new to this scene, use the Master Asset description.

OUTPUT (JSON only):
{
  "scene_id": "${scene.id}",
  "relevant_assets": [
    {
      "project_asset_id": "<must be from AVAILABLE PROJECT ASSETS>",
      "name": "string",
      "asset_type": "character | prop | location",
      "inherited_from": "master | previous_scene_instance",
      "starting_description": "string",
      "requires_visual_update": boolean,
      "status_tags_inherited": ["string"],
      "relevance_rationale": "string"
    }
  ],
  "new_assets_required": [
    { "name": "string", "asset_type": "character | prop | location", "description": "string", "justification": "string" }
  ]
}

Generate the JSON output now.
`;
  }

  private parseRelevanceResponse(aiResponse: string): SceneAssetRelevanceResult {
    try {
      const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
      if (!jsonMatch) throw new Error('No JSON found in AI response');
      return JSON.parse(jsonMatch[0]) as SceneAssetRelevanceResult;
    } catch (e) {
      throw new Error(`Failed to parse AI relevance response: ${e instanceof Error ? e.message : String(e)}`);
    }
  }
}
```

#### **1.2 Add Relevance Endpoint**

```typescript
// backend/src/routes/sceneAssets.ts (add to existing file)
import { SceneAssetRelevanceService } from '../services/sceneAssetRelevanceService.js';

/**
 * POST /api/projects/:projectId/scenes/:sceneId/assets/detect-relevance
 * AI agent detects which assets are needed for this scene
 */
router.post('/:projectId/scenes/:sceneId/assets/detect-relevance', async (req, res) => {
  try {
    const userId = req.user!.id;
    const { projectId, sceneId } = req.params;

    const { data: project, error: projectError } = await supabase
      .from('projects')
      .select('id, active_branch_id')
      .eq('id', projectId)
      .eq('user_id', userId)
      .single();

    if (projectError || !project) {
      return res.status(404).json({ error: 'Project not found' });
    }

    const { data: scene, error: sceneError } = await supabase
      .from('scenes')
      .select('id, branch_id')
      .eq('id', sceneId)
      .eq('branch_id', project.active_branch_id)
      .single();

    if (sceneError || !scene) {
      return res.status(404).json({ error: 'Scene not found' });
    }

    const relevanceService = new SceneAssetRelevanceService();
    const result = await relevanceService.detectRelevantAssets(sceneId, project.active_branch_id);

    res.json(result);
  } catch (error) {
    console.error('[SceneAssets] Relevance detection error:', error);
    res.status(500).json({
      error: 'Asset relevance detection failed',
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});
```

---

### **Task 2: Frontend Service - Scene Asset Instance Management**

**Purpose**: Create a frontend API client for CRUD operations on scene asset instances. Use with **React Query** in Stage 8: `useQuery` for list (and optional relevance result), `useMutation` for create/update/delete/inherit/generate-image, to align with existing tech stack.

**Files to Create**:
- `src/lib/services/sceneAssetService.ts` (new)

**Implementation**:

```typescript
// src/lib/services/sceneAssetService.ts
import { supabase } from '@/lib/supabase';
import type {
  SceneAssetInstance,
  CreateSceneAssetInstanceRequest,
  UpdateSceneAssetInstanceRequest,
  SceneAssetRelevanceResult,
} from '@/types/scene';

export interface BulkImageGenerationRequest {
  instanceIds: string[];
}

export interface BulkImageGenerationResult {
  jobId: string;
  totalJobs: number;
  statuses: Array<{
    instanceId: string;
    jobId: string;
    status: 'queued' | 'processing' | 'completed' | 'failed';
  }>;
}

class SceneAssetService {
  /**
   * List all asset instances for a scene
   */
  async listSceneAssets(projectId: string, sceneId: string): Promise<SceneAssetInstance[]> {
    const { data: { session } } = await supabase.auth.getSession();
    if (!session?.access_token) {
      throw new Error('User not authenticated');
    }

    const response = await fetch(
      `/api/projects/${projectId}/scenes/${sceneId}/assets`,
      {
        headers: {
          'Authorization': `Bearer ${session.access_token}`,
        },
      }
    );

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || 'Failed to fetch scene assets');
    }

    return response.json();
  }

  /**
   * Create a new scene asset instance
   */
  async createSceneAsset(
    projectId: string,
    request: CreateSceneAssetInstanceRequest
  ): Promise<SceneAssetInstance> {
    const { data: { session } } = await supabase.auth.getSession();
    if (!session?.access_token) {
      throw new Error('User not authenticated');
    }

    const response = await fetch(
      `/api/projects/${projectId}/scenes/${request.sceneId}/assets`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${session.access_token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(request),
      }
    );

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || 'Failed to create scene asset');
    }

    return response.json();
  }

  /**
   * Update scene asset instance
   */
  async updateSceneAsset(
    projectId: string,
    sceneId: string,
    instanceId: string,
    updates: UpdateSceneAssetInstanceRequest
  ): Promise<SceneAssetInstance> {
    const { data: { session } } = await supabase.auth.getSession();
    if (!session?.access_token) {
      throw new Error('User not authenticated');
    }

    const response = await fetch(
      `/api/projects/${projectId}/scenes/${sceneId}/assets/${instanceId}`,
      {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${session.access_token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(updates),
      }
    );

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || 'Failed to update scene asset');
    }

    return response.json();
  }

  /**
   * Delete scene asset instance
   */
  async deleteSceneAsset(
    projectId: string,
    sceneId: string,
    instanceId: string
  ): Promise<void> {
    const { data: { session } } = await supabase.auth.getSession();
    if (!session?.access_token) {
      throw new Error('User not authenticated');
    }

    const response = await fetch(
      `/api/projects/${projectId}/scenes/${sceneId}/assets/${instanceId}`,
      {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${session.access_token}`,
        },
      }
    );

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || 'Failed to delete scene asset');
    }
  }

  /**
   * Trigger asset inheritance from prior scene
   */
  async inheritAssets(projectId: string, sceneId: string): Promise<{ count: number }> {
    const { data: { session } } = await supabase.auth.getSession();
    if (!session?.access_token) {
      throw new Error('User not authenticated');
    }

    const response = await fetch(
      `/api/projects/${projectId}/scenes/${sceneId}/assets/inherit`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${session.access_token}`,
        },
      }
    );

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || 'Failed to inherit assets');
    }

    return response.json();
  }

  /**
   * Detect relevant assets using AI
   */
  async detectRelevantAssets(
    projectId: string,
    sceneId: string
  ): Promise<SceneAssetRelevanceResult> {
    const { data: { session } } = await supabase.auth.getSession();
    if (!session?.access_token) {
      throw new Error('User not authenticated');
    }

    const response = await fetch(
      `/api/projects/${projectId}/scenes/${sceneId}/assets/detect-relevance`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${session.access_token}`,
        },
      }
    );

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || 'Failed to detect relevant assets');
    }

    return response.json();
  }

  /**
   * Generate image for single scene asset instance
   */
  async generateSceneAssetImage(
    projectId: string,
    sceneId: string,
    instanceId: string
  ): Promise<{ jobId: string; status: string }> {
    const { data: { session } } = await supabase.auth.getSession();
    if (!session?.access_token) {
      throw new Error('User not authenticated');
    }

    const response = await fetch(
      `/api/projects/${projectId}/scenes/${sceneId}/assets/${instanceId}/generate-image`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${session.access_token}`,
        },
      }
    );

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || 'Failed to generate image');
    }

    return response.json();
  }

  /**
   * Bulk generate images for multiple scene asset instances
   */
  async bulkGenerateImages(
    projectId: string,
    sceneId: string,
    instanceIds: string[]
  ): Promise<BulkImageGenerationResult> {
    const results = await Promise.allSettled(
      instanceIds.map(id => this.generateSceneAssetImage(projectId, sceneId, id))
    );

    const statuses = results.map((result, idx) => {
      if (result.status === 'fulfilled') {
        return {
          instanceId: instanceIds[idx],
          jobId: result.value.jobId,
          status: result.value.status as any,
        };
      } else {
        return {
          instanceId: instanceIds[idx],
          jobId: '',
          status: 'failed' as const,
        };
      }
    });

    return {
      jobId: `bulk-${Date.now()}`,
      totalJobs: instanceIds.length,
      statuses,
    };
  }
}

export const sceneAssetService = new SceneAssetService();
```

---

### **Task 3: UI Component - Rebuild Stage8VisualDefinition**

**Purpose**: Replace mock data with production logic; implement three-panel layout with real API integration and continuity context.

**Files to Modify**:
- `src/components/pipeline/Stage8VisualDefinition.tsx`
- `src/pages/ProjectView.tsx` (pass `projectId` to Stage 8; PRD requires project context)

**Layout (PRD-aligned):**
- **Top:** **Continuity Header / Rearview Mirror** – Collapsible component showing "Previous Scene End-State Summary" (and optionally inheritance path). Required by PRD Section 5.3 for Phase B stages 7–9.
- **Left:** Scene Visual Elements Panel (grouped list)
- **Center:** Visual State Editor (selected asset)
- **Right:** Asset Drawer (global/project library access)

**Key Changes**:

1. **Data Loading on Mount**:
   - Use React Query (`useQuery`) for scene asset list; `useMutation` for create/update/delete and inherit.
   - Fetch scene asset instances from API; if empty, show empty state with "Detect Required Assets" and "Add Manually" (do not auto-run AI on first load; let user choose).

2. **Continuity Header (Rearview Mirror)**:
   - Load previous scene's end-state summary (e.g. from `scenes.end_state_summary` or assembled from prior scene asset instances).
   - Display inheritance path for selected asset when in editor (e.g. "Inheriting from Scene 4").

3. **Scene Visual Elements Panel (Left)**:
   - Group assets by type (Characters, Locations, Props)
   - Display source badge (Master, Prior Scene, New)
   - Show status: Unreviewed, Edited, Locked (based on `image_key_url` and `modification_count`)
   - Multi-select checkboxes for bulk generation
   - If "suggested assets" (from `new_assets_required`) are shown, display them with distinct styling and actions: "Add from library" / "Ignore" (no auto-creation).

4. **Visual State Editor (Center)**:
   - Editable `effective_description` textarea
   - Display `project_asset` details (name, type, master image)
   - Show inheritance info (`inherited_from_instance_id`) and "Inheriting from Scene N" when applicable
   - Display audit trail (`modification_count`, `last_modified_field`)
   - Lock/Unlock button (updates `modification_reason`)
   - Optional (future): "Continuity Conflict" warning if prior scene end-state clearly contradicts current script; let user choose which description to use.

5. **Asset Drawer (Right)**:
   - **Add from Project Assets** button → opens `AssetDrawer` component
   - **Create New Scene Asset** button → inline form
   - When an asset is added from the drawer, show "Inheritance Source: Master" so the user knows they start from a clean slate.
   - Drag-and-drop support (optional enhancement)

**Pseudocode Structure**:

```typescript
interface Stage8VisualDefinitionProps {
  projectId: string;  // Required – pass from ProjectView (same as Stage 7/10)
  sceneId: string;
  onComplete: () => void;
  onBack: () => void;
}

export function Stage8VisualDefinition({ projectId, sceneId, onComplete, onBack }: Props) {
  const [selectedAsset, setSelectedAsset] = useState<SceneAssetInstance | null>(null);
  const [selectedForGeneration, setSelectedForGeneration] = useState<string[]>([]);
  const [assetDrawerOpen, setAssetDrawerOpen] = useState(false);
  const [costConfirmOpen, setCostConfirmOpen] = useState(false);

  const { data: sceneAssets, isLoading, refetch } = useQuery({
    queryKey: ['scene-assets', projectId, sceneId],
    queryFn: () => sceneAssetService.listSceneAssets(projectId, sceneId),
  });

  // If no assets, show empty state (do not auto-run AI; user chooses Detect or Add manually)
  if (!isLoading && sceneAssets?.length === 0) {
    return <EmptyStatePanel onDetectAssets={handleDetectAndPopulateAssets} onAddManually={() => setAssetDrawerOpen(true)} />;
  }

  async function handleDetectRelevantAssets() {
    const relevance = await sceneAssetService.detectRelevantAssets(projectId, sceneId);
    // Create scene instances only for relevance.relevant_assets (all have valid project_asset_id)
    for (const ra of relevance.relevant_assets) {
      await sceneAssetService.createSceneAsset(projectId, { sceneId, projectAssetId: ra.project_asset_id, ... });
    }
    refetch();
    if (relevance.new_assets_required?.length) setNewAssetsRequired(relevance.new_assets_required);
  }

  function handleBulkGenerateClick() {
    if (selectedForGeneration.length === 0) return;
    setCostConfirmOpen(true);  // Show cost preview modal (Task 7.0)
  }

  async function handleBulkGenerateConfirmed() {
    setCostConfirmOpen(false);
    setGenerating(true);
    try {
      const result = await sceneAssetService.bulkGenerateImages(projectId, sceneId, selectedForGeneration);
      await pollJobCompletion(result.statuses);
      toast.success('Images generated successfully');
      refetch();
      setSelectedForGeneration([]);
    } catch (error) {
      toast.error(`Bulk generation failed: ${error.message}`);
    } finally {
      setGenerating(false);
    }
  }

  return (
    <div className="flex-1 flex flex-col overflow-hidden">
      {/* Top: Continuity Header / Rearview Mirror */}
      <ContinuityHeader previousSceneEndState={previousSceneEndState} />

      <div className="flex-1 flex overflow-hidden">
        {/* Left: Scene Visual Elements Panel */}
        <SceneAssetListPanel
          assets={sceneAssets ?? []}
          selectedAsset={selectedAsset}
          selectedForGeneration={selectedForGeneration}
          onSelectAsset={setSelectedAsset}
          onToggleSelection={handleToggleSelection}
          onBulkGenerate={handleBulkGenerateClick}
          isGenerating={isGenerating}
        />

        {/* Center: Visual State Editor */}
        <VisualStateEditorPanel
          selectedAsset={selectedAsset}
          onUpdateAsset={handleUpdateAsset}
          onGenerateImage={handleGenerateImage}
          projectId={projectId}
          sceneId={sceneId}
        />

        {/* Right: Asset Drawer Trigger + Actions */}
        <AssetDrawerTriggerPanel
          onOpenAssetDrawer={() => setAssetDrawerOpen(true)}
          onCreateNewAsset={handleCreateNewAsset}
          onBack={onBack}
          onComplete={handleProceedToStage9}
        />

        <AssetDrawer
          projectId={projectId}
          sceneId={sceneId}
          isOpen={assetDrawerOpen}
          onClose={() => setAssetDrawerOpen(false)}
          onSceneInstanceCreated={handleSceneInstanceCreated}
        />
      </div>

      {/* Cost confirmation modal (Task 7.0) */}
      <CostConfirmModal
        open={costConfirmOpen}
        onClose={() => setCostConfirmOpen(false)}
        selectedCount={selectedForGeneration.length}
        estimatedCredits={selectedForGeneration.length * costPerImage}
        onConfirm={handleBulkGenerateConfirmed}
      />
    </div>
  );
}
```

---

### **Task 4: UI Subcomponent - SceneAssetListPanel (Left Panel)**

**Purpose**: Render grouped list of scene asset instances with multi-select and status indicators.

**Files to Create**:
- `src/components/pipeline/Stage8/SceneAssetListPanel.tsx` (new)

**Features**:
- Group by asset type (Characters, Locations, Props)
- Type icons (User, MapPin, Package from lucide-react)
- Status badges: Unreviewed (gray), Edited (amber), Locked (emerald)
- Checkbox for bulk generation selection
- Click to select asset for editing
- Bulk generation button at bottom (disabled if no selection; opens cost confirmation modal per Task 7.0 before running)
- **Suggested assets (from `new_assets_required`):** If the relevance agent returns `new_assets_required`, show them in a distinct section (e.g. "Suggested – not in library") with distinct styling (e.g. yellow/amber border or badge). Actions per item: "Add from library" (opens Asset Drawer) or "Ignore". Do not auto-create project assets or scene instances from these.

**Example Structure**:
```tsx
export function SceneAssetListPanel({
  assets,
  selectedAsset,
  selectedForGeneration,
  onSelectAsset,
  onToggleSelection,
  onBulkGenerate,
  isGenerating,
}: Props) {
  const groupedAssets = useMemo(() => ({
    character: assets.filter(a => a.project_asset?.asset_type === 'character'),
    location: assets.filter(a => a.project_asset?.asset_type === 'location'),
    prop: assets.filter(a => a.project_asset?.asset_type === 'prop'),
  }), [assets]);

  const getReviewStatus = (asset: SceneAssetInstance): 'unreviewed' | 'edited' | 'locked' => {
    if (!asset.image_key_url) return 'unreviewed';
    if (asset.modification_count && asset.modification_count > 0) return 'edited';
    return 'locked';
  };

  return (
    <motion.div className="w-80 border-r border-border/50 bg-card/30 backdrop-blur-sm flex flex-col">
      <div className="p-4 border-b border-border/50">
        <h2 className="font-display text-lg font-semibold">Scene Assets</h2>
        <p className="text-xs text-muted-foreground mt-1">
          {assets.length} assets • {assets.filter(a => a.image_key_url).length} with visuals
        </p>
      </div>

      <ScrollArea className="flex-1">
        <div className="p-2">
          {Object.entries(groupedAssets).map(([type, typeAssets]) => (
            <AssetTypeGroup
              key={type}
              type={type}
              assets={typeAssets}
              selectedAssetId={selectedAsset?.id}
              selectedForGeneration={selectedForGeneration}
              onSelectAsset={onSelectAsset}
              onToggleSelection={onToggleSelection}
              getReviewStatus={getReviewStatus}
            />
          ))}
        </div>
      </ScrollArea>

      <div className="p-4 border-t border-border/50">
        <Button
          variant="gold"
          className="w-full"
          disabled={selectedForGeneration.length === 0 || isGenerating}
          onClick={onBulkGenerate}
        >
          {isGenerating ? (
            <>
              <RefreshCw className="w-4 h-4 mr-2 animate-spin" />
              Generating ({selectedForGeneration.length})...
            </>
          ) : (
            <>
              <Sparkles className="w-4 h-4 mr-2" />
              Generate Visuals ({selectedForGeneration.length})
            </>
          )}
        </Button>
      </div>
    </motion.div>
  );
}
```

---

### **Task 5: UI Subcomponent - VisualStateEditorPanel (Center Panel)**

**Purpose**: Display and edit the selected scene asset instance's visual description.

**Files to Create**:
- `src/components/pipeline/Stage8/VisualStateEditorPanel.tsx` (new)

**Features**:
- Displays `project_asset` master details (name, type, base description, master image)
- Editable `effective_description` textarea (updates `description_override`)
- Shows inheritance chain (`inherited_from_instance_id`) and "Inheriting from Scene N" when applicable
- Displays audit trail (`modification_count`, `last_modified_field`, `modification_reason`)
- "Generate Image" button (single asset)
- "Lock Asset" button (once image is generated and approved)
- Status tags editor (chips for "muddy", "bloody", etc.) with **instance-level Carry Forward toggle** (Lock/Chain icon) – when enabled, this instance's state (including status_tags) is used as the starting state for the next scene. Syncs to `scene_asset_instances.carry_forward`.
- **Optional (future):** "Continuity Conflict" – if prior scene end-state summary clearly contradicts the current scene script (e.g. prior: "car exploded", script: "car drives away"), show a warning in the editor and a "Reconcile" action so the user can choose which description to use.

**Example Structure**:
```tsx
export function VisualStateEditorPanel({
  selectedAsset,
  onUpdateAsset,
  onGenerateImage,
  projectId,
  sceneId,
}: Props) {
  const [editedDescription, setEditedDescription] = useState('');
  const [statusTags, setStatusTags] = useState<string[]>([]);
  const [carryForward, setCarryForward] = useState(true);

  useEffect(() => {
    if (selectedAsset) {
      setEditedDescription(selectedAsset.effective_description);
      setStatusTags(selectedAsset.status_tags);
      setCarryForward(selectedAsset.carry_forward);
    }
  }, [selectedAsset]);

  const handleSaveDescription = async () => {
    if (!selectedAsset) return;
    
    await onUpdateAsset(selectedAsset.id, {
      descriptionOverride: editedDescription,
      statusTags,
      carryForward,
      modificationReason: 'User edited description in Stage 8',
    });
  };

  if (!selectedAsset) {
    return (
      <div className="flex-1 flex items-center justify-center">
        <p className="text-muted-foreground">Select an asset to edit</p>
      </div>
    );
  }

  return (
    <motion.div className="flex-1 flex flex-col overflow-hidden">
      <div className="p-4 border-b border-border/50">
        <div className="flex items-center gap-3">
          <AssetTypeIcon type={selectedAsset.project_asset?.asset_type} />
          <div>
            <h3 className="text-lg font-semibold">{selectedAsset.project_asset?.name}</h3>
            <p className="text-xs text-muted-foreground">
              {selectedAsset.inherited_from_instance_id ? 'Inherited from prior scene' : 'From Master Assets'}
            </p>
          </div>
        </div>
      </div>

      <ScrollArea className="flex-1">
        <div className="p-6 space-y-6">
          {/* Master Asset Reference */}
          <MasterAssetReference asset={selectedAsset.project_asset} />

          {/* Scene-Specific Description Editor */}
          <DescriptionEditor
            value={editedDescription}
            onChange={setEditedDescription}
            onSave={handleSaveDescription}
          />

          {/* Status Tags Editor */}
          <StatusTagsEditor
            tags={statusTags}
            onChange={setStatusTags}
          />

          {/* Carry Forward Toggle */}
          <CarryForwardToggle
            value={carryForward}
            onChange={setCarryForward}
          />

          {/* Image Display/Generation */}
          <ImageSection
            imageUrl={selectedAsset.image_key_url}
            onGenerate={() => onGenerateImage(selectedAsset.id)}
          />

          {/* Audit Trail */}
          {selectedAsset.modification_count && selectedAsset.modification_count > 0 && (
            <AuditTrail
              modificationCount={selectedAsset.modification_count}
              lastModifiedField={selectedAsset.last_modified_field}
              modificationReason={selectedAsset.modification_reason}
            />
          )}
        </div>
      </ScrollArea>
    </motion.div>
  );
}
```

---

### **Task 6: Asset Drawer Integration**

**Purpose**: Allow users to add assets from global/project libraries to the current scene.

**Files to Modify**:
- `src/components/pipeline/AssetDrawer.tsx` (minor modifications for scene context)
- `src/components/pipeline/Stage8VisualDefinition.tsx` (integration)

**Implementation**:

#### **6.1 Modify AssetDrawer for Scene Assignment**

**Current behavior**: AssetDrawer clones global assets into `project_assets`.

**New behavior**: After cloning into `project_assets`, optionally create a `scene_asset_instance` for the current scene.

**Approach**: Add optional `sceneId` prop to AssetDrawer. When provided, after cloning, automatically create a scene instance.

```typescript
// Modified AssetDrawer.tsx
interface AssetDrawerProps {
  projectId: string;
  isOpen: boolean;
  onClose: () => void;
  onAssetCloned?: (asset: ProjectAsset) => void;
  filterType?: AssetType;
  // NEW: Optional scene context for auto-creating scene instances
  sceneId?: string;
  onSceneInstanceCreated?: (instance: SceneAssetInstance) => void;
}

// In handleCloneAsset (after cloning to project_assets):
if (sceneId && onSceneInstanceCreated) {
  // Create scene asset instance
  const instance = await sceneAssetService.createSceneAsset(projectId, {
    sceneId,
    projectAssetId: clonedAsset.id,
    descriptionOverride: null, // Use master description initially
    statusTags: [],
    carryForward: true,
  });
  
  onSceneInstanceCreated(instance);
}
```

#### **6.2 Stage 8 Integration**

```tsx
// In Stage8VisualDefinition.tsx
<AssetDrawer
  projectId={projectId}
  sceneId={sceneId}
  isOpen={assetDrawerOpen}
  onClose={() => setAssetDrawerOpen(false)}
  onSceneInstanceCreated={handleSceneInstanceCreated}
/>

async function handleSceneInstanceCreated(instance: SceneAssetInstance) {
  refetch();  // Refresh scene assets list
  toast.success(`Added ${instance.project_asset?.name} to scene`);
  setAssetDrawerOpen(false);
}
```

---

### **Task 7.0: Cost Preview & Confirmation (PRD Cost Discipline)**

**Purpose**: Surface cost implications and require explicit user confirmation before bulk image generation (PRD: "All high-cost operations require explicit user confirmation").

**Implementation**:
1. **Cost calculation:** Before "Generate Visuals" runs, compute `selectedCount × costPerImage` (use backend or a known constant; e.g. from `image_generation_jobs.estimated_cost` or a config).
2. **Confirmation modal:** When the user clicks "Generate Visuals (N)", open a modal that shows:
   - "This will generate [N] image(s) and use approximately [X] credits. Continue?"
   - Buttons: "Cancel" / "Confirm & Generate".
3. Only after "Confirm & Generate" call the bulk generation API. If the user cancels, do nothing.

**UI copy (example):** "This action will use approximately [X] credits and generate [Y] image(s). Continue?"

---

### **Task 7: Bulk Image Generation Orchestration**

**Purpose**: Handle multi-select image generation with job polling and progress feedback. **Must be gated by Task 7.0 (cost confirmation).**

**Implementation Strategy**:
1. User selects multiple assets via checkboxes
2. Clicks "Generate Visuals (N)" button
3. Frontend calls `sceneAssetService.bulkGenerateImages(projectId, sceneId, instanceIds[])`
4. Service initiates parallel generation jobs
5. Poll each job individually (or use a unified polling mechanism)
6. Update UI with per-asset status (queued → generating → completed/failed)
7. On completion, refresh scene assets list to show new `image_key_url` values

**UI Feedback**:
- Show spinner on "Generate Visuals" button
- Display toast notifications for completion/failure
- Optionally show individual job statuses in a modal (advanced)

**Example Polling Logic**:
```typescript
async function pollJobCompletion(statuses: Array<{ instanceId: string; jobId: string }>) {
  const pollInterval = 2000; // 2 seconds
  const maxAttempts = 60; // 2 minutes total

  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    const allCompleted = await Promise.all(
      statuses.map(async ({ jobId }) => {
        const job = await fetch(`/api/images/jobs/${jobId}`).then(r => r.json());
        return job.status === 'completed' || job.status === 'failed';
      })
    );

    if (allCompleted.every(c => c)) {
      break; // All jobs finished
    }

    await new Promise(resolve => setTimeout(resolve, pollInterval));
  }
}
```

---

### **Task 8: Empty State & Asset Detection Flow**

**Purpose**: Handle first-time Stage 8 entry for a scene with no prior asset instances.

**UX Flow**:
1. User enters Stage 8 for the first time
2. No scene asset instances exist yet
3. Show empty state with two options:
   - **"Detect Required Assets"** (AI agent) → auto-detects from shot list
   - **"Add Assets Manually"** → opens Asset Drawer

**Implementation**:

```tsx
// In Stage8VisualDefinition.tsx
if (loading) {
  return <LoadingSpinner />;
}

if (sceneAssets.length === 0) {
  return (
    <EmptyStatePanel
      onDetectAssets={handleDetectAndPopulateAssets}
      onAddManually={() => setAssetDrawerOpen(true)}
    />
  );
}

async function handleDetectAndPopulateAssets() {
  try {
    setDetecting(true);
    
    const relevance = await sceneAssetService.detectRelevantAssets(projectId, sceneId);
    
    // Create scene asset instances ONLY from relevant_assets (all have valid project_asset_id).
    // Do NOT create from new_assets_required – those are advisory only; user adds via Asset Drawer or ignores.
    const createPromises = relevance.relevant_assets.map(ra =>
      sceneAssetService.createSceneAsset(projectId, {
        sceneId,
        projectAssetId: ra.project_asset_id,
        descriptionOverride: ra.starting_description ? ra.starting_description : undefined,
        statusTags: ra.status_tags_inherited ?? [],
        carryForward: true,
      })
    );
    
    await Promise.all(createPromises);
    refetch();  // or loadSceneAssets()
    
    toast.success(`Detected ${relevance.relevant_assets.length} relevant assets`);
    
    if (relevance.new_assets_required?.length > 0) {
      setNewAssetsRequired(relevance.new_assets_required);
      setNewAssetsModalOpen(true);  // Show as suggestions; user can "Add from library" or "Ignore"
    }
  } catch (error) {
    toast.error(`Asset detection failed: ${error.message}`);
  } finally {
    setDetecting(false);
  }
}
```

**EmptyStatePanel Component**:
```tsx
function EmptyStatePanel({ onDetectAssets, onAddManually }: Props) {
  return (
    <div className="flex-1 flex items-center justify-center">
      <Card className="max-w-md text-center p-8">
        <Sparkles className="w-16 h-16 mx-auto mb-4 text-primary" />
        <h2 className="text-2xl font-bold mb-2">No Assets Defined Yet</h2>
        <p className="text-muted-foreground mb-6">
          Define which characters, props, and locations appear at the start of this scene.
        </p>
        
        <div className="space-y-3">
          <Button variant="gold" className="w-full" onClick={onDetectAssets}>
            <Brain className="w-4 h-4 mr-2" />
            Detect Required Assets (AI)
          </Button>
          
          <Button variant="outline" className="w-full" onClick={onAddManually}>
            <Plus className="w-4 h-4 mr-2" />
            Add Assets Manually
          </Button>
        </div>
      </Card>
    </div>
  );
}
```

---

### **Task 9: Status Tags Editor**

**Purpose**: Allow users to add/remove status metadata tags (e.g., "muddy", "bloody", "torn") to scene asset instances. Tags describe visual conditions and can persist to the next scene when Carry Forward is enabled.

**Persistence (instance-level):** The current schema has a single `carry_forward` boolean per `scene_asset_instance`. When `carry_forward` is true, the instance's state (including `status_tags`) is inherited by the next scene. The UI must show a clear **"Carry Forward"** toggle (e.g. Lock or Chain icon) next to the status tags section so users can choose whether this instance's state persists. Sync updates to `scene_asset_instances.carry_forward`.

**Future enhancement (per-tag carry):** Per-tag "sticky" (e.g. "muddy" carries forward but "bloody" does not) would require a schema change (e.g. `sticky_tags: string[]` or `status_tags` as `{ tag: string; carry_forward: boolean }[]`). Document as optional follow-up; for v1 use instance-level only.

```tsx
// src/components/pipeline/Stage8/StatusTagsEditor.tsx
export function StatusTagsEditor({ tags, onChange }: Props) {
  const [inputValue, setInputValue] = useState('');

  const handleAddTag = () => {
    if (inputValue.trim() && !tags.includes(inputValue.trim())) {
      onChange([...tags, inputValue.trim()]);
      setInputValue('');
    }
  };

  const handleRemoveTag = (tag: string) => {
    onChange(tags.filter(t => t !== tag));
  };

  return (
    <div>
      <label className="text-sm font-medium flex items-center gap-2 mb-2">
        <Tag className="w-4 h-4 text-primary" />
        Status Tags (Conditions)
      </label>
      
      <div className="flex flex-wrap gap-2 mb-2">
        {tags.map(tag => (
          <Badge key={tag} variant="secondary" className="gap-1">
            {tag}
            <X
              className="w-3 h-3 cursor-pointer hover:text-destructive"
              onClick={() => handleRemoveTag(tag)}
            />
          </Badge>
        ))}
      </div>

      <div className="flex gap-2">
        <Input
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          onKeyDown={(e) => e.key === 'Enter' && handleAddTag()}
          placeholder="Add tag (e.g., muddy, torn)"
        />
        <Button size="sm" onClick={handleAddTag}>
          <Plus className="w-4 h-4" />
        </Button>
      </div>

      <p className="text-xs text-muted-foreground mt-2">
        Tags describe visual conditions (muddy, bloody, torn). They carry forward to next scene if enabled.
      </p>
    </div>
  );
}
```

---

### **Task 10: Gatekeeper Logic - Proceed to Stage 9**

**Purpose**: Ensure all required assets have generated images before allowing progression to Stage 9.

**Validation**:
- Check that all scene asset instances have `image_key_url` populated
- (Optional) Check that at least one asset exists per type mentioned in shot list

**Implementation**:

```tsx
// In Stage8VisualDefinition.tsx
async function handleProceedToStage9() {
  // Validate that all assets have images
  const missingImages = sceneAssets.filter(a => !a.image_key_url);

  if (missingImages.length > 0) {
    toast.error(
      `Cannot proceed: ${missingImages.length} asset(s) missing visual references. Generate images first.`
    );
    return;
  }

  // All checks passed
  onComplete();
}
```

---

### **Task 11: Testing & Polish**

**Testing Checklist**:
1. **Asset Inheritance**: Verify Scene 1 bootstraps from `project_assets`; Scene N inherits from Scene N-1
2. **AI Relevance Detection**: Test with various shot lists; ensure correct asset identification
3. **Bulk Image Generation**: Test with 1, 5, and 10+ assets; verify polling and error handling
4. **Status Tags**: Add/remove tags; verify carry_forward behavior
5. **Audit Trail**: Make multiple edits; verify `modification_count` increments
6. **Asset Drawer Integration**: Clone global asset → verify scene instance creation
7. **Empty State**: Test first-time entry → detect assets → populate list
8. **Gatekeeper**: Attempt to proceed without images → verify validation

**Polish Items**:
- Add loading skeletons for asset list
- Add error boundaries for API failures
- Add keyboard shortcuts (e.g., Ctrl+S to save description)
- Add drag-and-drop reordering (optional enhancement)
- Add asset search/filter in left panel (if asset count is high)
- **Optional:** Bottom-docked "Bulk Generation Queue" status bar showing progress of current image jobs with per-job status and "Retry" for failures

---

## **Dependencies & Prerequisites**

- ✅ **Feature 5.1 (Scene Asset Instances)** – Already implemented
- ✅ **Stage 7 (Shot List)** – Must be locked before entering Stage 8
- ✅ **Stage 5 (Visual Style Lock)** – Required for image generation
- ❌ **AI Client Service** – Use existing LLM integration (e.g. Anthropic/OpenAI) for relevance agent; verify path in backend
- **ProjectView:** Must pass `projectId` to `Stage8VisualDefinition` (same pattern as Stage 7/10)

---