The **Feature 4.2: Script Hub Implementation Plan** is technically sound and aligns well with the "Phase B Foundation" goals established in your project overview. It correctly prioritizes the "Global-to-Local" inheritance model by attempting to pull data from the narrative (Stage 4) into the production environment (Stage 6).

However, there are several critical performance risks and logic gaps that should be addressed before you start coding.

### **1. What Is Solid and Well-Designed?**

* **Database Caching Strategy:** Task 4 (adding `expected_characters` and `expected_location` columns) is essential. Without this, your LLM costs and page load times would scale linearly with the number of scenes, which is unsustainable for a production app.
* **Rule-Based Continuity Analyzer:** Choosing a rule-based approach for the MVP is the correct strategic move. LLMs are prone to "hallucinating" continuity errors that don't exist; a deterministic check against `updated_at` timestamps and `video_complete` statuses is much more reliable for status tracking.
* **Regex Fallback for Locations:** Using regex to parse scene headings (e.g., "INT. KITCHEN") before calling an LLM is a great optimization that saves both time and money.

---

### **2. Key Flaws and Risks (High Priority)**

* **The "Sequential Extraction" Performance Trap:**
Task 3 suggests enriching scenes during the `GET /scenes` call. If a user has 20 scenes and the LLM takes 2 seconds per scene, the initial page load could take **40 seconds**.
* *Risk:* This will likely trigger a 504 Gateway Timeout on most hosting platforms (like Fly.io).
* *Fix:* Extraction should ideally happen as a **background job** when the user "Approves" the script in Stage 4, or you must use `Promise.all` with a concurrency limit immediately in the MVP.


* **Character Mapping Disconnect:**
The plan extracts `expectedCharacters` as strings (e.g., "ALICE"). However, your PRD emphasizes **Stage 5 Master Assets**.
* *Risk:* If the LLM extracts "ALICE" but your Stage 5 asset is named "Alice Smith," the UI won't be able to easily link the scene to the global asset's visual profile or voice seed.
* *Fix:* The extraction service should eventually "fuzzy match" extracted names against the project's Stage 5 `master_assets` table.



---

### **3. Medium / Low-Level Design Gaps**

* **Upstream Invalidation Logic:** The plan mentions checking if upstream artifacts changed, but it doesn't explicitly define what happens to the **cache** when a user goes back to Stage 4 and edits the script.
* *Gap:* If the `script_excerpt` changes, the `dependencies_extracted_at` timestamp must be cleared or compared against the `scenes.updated_at` to trigger a re-extraction.


* **"Enter Scene Pipeline" Action:**
The plan states this navigates to Stage 7.
* *Gap:* You need to ensure that the "active scene context" is persisted in the URL (e.g., `/project/:id/stage/7?sceneId=:sceneId`) so that when the user refreshes Stage 7, they don't lose their place in the 12-stage pipeline.



---

### **4. Comparison to Project Specs & 4.1 Summary**

* **Alignment with 4.1:** The plan perfectly utilizes the `script_excerpt` and `continuity_broken` status you implemented in the previous task. This shows excellent continuity in your development logic.
* **Alignment with PRD:** The "Prior Scene End State" being a placeholder is consistent with the PRD's 12-stage flow. Since Stage 12 (Video Gen) hasn't been built yet, the data to populate this field physically does not exist in your database.

### **Revised Implementation Order Suggestion**

To avoid the performance bottleneck, I recommend moving the **Database Migration (Task 4)** to the very beginning. This allows you to write your extraction logic in a way that checks the cache immediately, rather than trying to "enrich" the data on every single API call.

**Would you like to see a revised version of the `GET /api/projects/:id/scenes` logic that incorporates background processing or concurrency limits?**