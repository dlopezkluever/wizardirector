---
name: Shot Split and Merge
overview: Fix shot split to use "stretch" semantics (each new shot gets the original duration), add shot merge (merge with next/previous via toggle), and harden the split/merge pipeline with validation and docs.
todos: []
isProject: false
---

# Shot Split and Merge: Fix Semantics, Add Merge, Harden

## Context

- **PRD**: Stage 7 requires "Shot Splitting/Merging" and a "Shot Split / Merge Agent" that splits or merges shots deterministically ([project-overview.md](._docs/project-overview.md) 193–212, 549–585).
- **Current behavior**: Split is implemented but uses **subdivide** semantics: prompt says "Duration must sum to the original (e.g. 4+4 or 5+3)", so an 8s shot becomes two 4s shots.
- **Desired split**: **Stretch** semantics — splitting is for giving more time per clip (e.g. Veo3/Sora limits); each new shot should have the **same** duration as the original (8s → two 8s shots).
- **Merge**: Not implemented; PRD calls for it. Delete achieves removal but not a single coherent merged shot.

---

## 1. Fix split duration semantics (stretch only)

**Problem**: [backend/src/services/shotSplitService.ts](backend/src/services/shotSplitService.ts) prompts the LLM for durations that sum to the original and uses LLM-returned durations (or default 4) in `toShotForInsert`. That yields 4+4 for an 8s shot.

**Changes**:

- **Prompt**: In `shotSplitService.ts`, replace the duration requirement with: each new shot must have the **same duration as the original** (so each clip can use the full generator time limit). Remove "Duration must sum to the original (e.g. 4+4 or 5+3)" and the example `"duration": 4` in the output JSON; state that duration will be set server-side to the original shot’s duration.
- **Post-LLM override**: After building the two `ShotForInsert` objects from the LLM response, set `duration` on **both** to `originalShot.duration` (ignore LLM-supplied duration for the final payload). This guarantees stretch behavior regardless of model output.
- **`toShotForInsert`**: Keep using `raw.duration` only as an internal default when building the object; the caller’s override will replace it. No signature change required if we override in `splitShot` after `toShotForInsert`. Alternatively, pass `originalDuration` into `toShotForInsert` and use it when `raw.duration` is missing — but the clearest approach is a single place: override both results in `splitShot` to `originalShot.duration`.
- **Unit test**: In [backend/src/tests/shotExtraction.test.ts](backend/src/tests/shotExtraction.test.ts), update the split test so that for an original 8s shot the two returned shots both have `duration === 8` (and keep the mock LLM response as-is; the assertion should reflect the new semantics).
- **Docs**: Update [4.3-plan-v1.md](4.3-plan-v1.md) Task 5 snippet and [._docs/AI-agent-registry-context-flow-architecture.md](._docs/AI-agent-registry-context-flow-architecture.md) Shot Split Agent (lines ~581–598) to describe stretch semantics and that duration is set server-side.

---

## 2. Add shot merge (backend + route)

**Design**: Merge two consecutive shots into one. User selects a shot and chooses "Merge with next" (default) or "Merge with previous" via a toggle.

**Backend**:

- **New service**: `backend/src/services/shotMergeService.ts`
  - Input: two shot rows (same shape as used by split, or the DB row subset).
  - LLM prompt: combine dialogue, action, characters, setting, camera, continuity_flags into one coherent shot; **duration = sum of the two shots’ durations** (condense in time by combining content).
  - Output: single `ShotForInsert`-like object (reuse or mirror the shape used for insert after split). New `shot_id`: e.g. base from first shot + `-M` or derive from first shot’s id (e.g. `3B` + `3C` → `3B+3C` or `3B-M`). `beat_reference`: keep first shot’s or null.
  - Validation: require both shots to have same `scene_id`; optional: same or adjacent `shot_order` if we pass order.
- **Route**: `POST /api/projects/:id/scenes/:sceneId/shots/:shotId/merge`
  - Body: `{ direction: 'next' | 'previous' }`. Default (e.g. missing) = `'next'`.
  - Load project/scene (same auth as split), load shot by `shotId`, then load the next or previous shot by `shot_order` (next = same scene, `shot_order === current + 1`; previous = `shot_order === current - 1`). If no such neighbour, return 400.
  - Call merge service with the two shots, then: delete both shots, insert the single merged shot with `shot_order` = the lower of the two orders, then re-index `shot_order` for remaining shots in the scene if needed (same pattern as split: we remove two and add one, so we only need to shift orders for shots after the removed range).
  - Return `{ success: true, mergedShot: insertedRow }`.
- **Ordering**: When merging shot A (order 1) and B (order 2), merged shot gets `shot_order: 1`. Shots previously 3,4,… stay 3,4,… (no shift needed). When merging "with previous", we have current = B, previous = A; we still delete both and insert one at A’s order.

**Merge UX (frontend)**:

- In [src/components/pipeline/Stage7ShotList.tsx](src/components/pipeline/Stage7ShotList.tsx): add a "Merge" action next to Split/Delete. Logic:
  - **Merge with next**: enabled when `selectedShot` has a successor in `shots` (same list, next index). Call `POST .../shots/:shotId/merge` with `{ direction: 'next' }`.
  - **Merge with previous**: enabled when `selectedShot` has a predecessor. Call with `{ direction: 'previous' }`.
- **Toggle**: Provide a small toggle or segmented control: "Merge with next" vs "Merge with previous". Only one can be active; the Merge button is enabled when the chosen neighbour exists. If you want to avoid two buttons, a single "Merge" button plus a dropdown or toggle is enough.
- **Optional**: Merge confirmation dialog (e.g. "Merge 3B and 3C into one shot?") and optional guidance text for the LLM (same pattern as split). If scope allows, add; otherwise merge without guidance first.
- **Frontend API**: In [src/lib/services/shotService.ts](src/lib/services/shotService.ts), add `mergeShot(projectId, sceneId, shotId, direction: 'next' | 'previous')` calling the new endpoint and returning the merged shot; update local state (replace two shots with one).

---

## 3. Robustness and docs

- **Split**  
  - **Duration**: Handled by explicit override to `originalShot.duration` for both outputs (no reliance on LLM for final duration).  
  - **Parsing**: Existing try/catch and markdown stripping in `shotSplitService` are kept. Optional: one retry on JSON parse failure; optional: Zod schema for `new_shots` for clearer errors.  
  - **Validation**: Keep existing required-field checks (action, setting, camera); ensure `toShotForInsert` defaults (e.g. dialogue `''`, continuity_flags `[]`) remain so that stretch-only duration override does not introduce missing fields.

- **Merge**  
  - **Validation**: Reject if neighbour missing; validate LLM output has required fields (action, setting, camera, duration) before insert.  
  - **Idempotency**: Not required for this phase; single merge call is sufficient.

- **Docs**  
  - [4.3-plan-v1.md](4.3-plan-v1.md): Task 5 — state that split uses stretch semantics (each new shot duration = original). Add a short "Task 5b" or "Shot Merge" section for merge (service + route + UX with next/previous toggle).  
  - [._docs/AI-agent-registry-context-flow-architecture.md](._docs/AI-agent-registry-context-flow-architecture.md): Update Shot Split Agent to stretch semantics; add a "Shot Merge Agent" subsection (purpose, input: two shots + optional guidance, output: one shot, duration = sum, deterministic merge of content).

---

## 4. Implementation order

1. **Split semantics**: Update prompt and add duration override in `shotSplitService.ts`; update test; update 4.3-plan and AI-agent-registry.
2. **Merge service**: Implement `shotMergeService.ts` (LLM merge prompt, single output, duration = sum, shot_id convention).
3. **Merge route**: Add `POST .../shots/:shotId/merge` with `direction`, auth, load two shots, call service, delete two, insert one, return merged shot.
4. **Frontend merge**: Add `mergeShot` to `shotService.ts`; add Merge button + "Merge with next" / "Merge with previous" toggle and enable rules in `Stage7ShotList`; wire success to replace two shots with one in state and optionally select the new shot.
5. **Docs**: Final pass on plan and AI-agent-registry for merge agent and stretch semantics.

---

## 5. Out of scope for this plan

- **Subdivide mode**: Not implemented; split is stretch-only per your choice.
- **Multi-select merge**: Only "merge with next/previous" (single selected shot + toggle); no multi-select two arbitrary shots.
- **Versioning / Phase 10**: No change to versioning or immutability; merge/split remain in-place updates as in current 4.3 scope.

---

## Summary

| Area | Action |
|------|--------|
| Split | Stretch only: prompt + override both new shots’ `duration` to `originalShot.duration`; update tests and docs. |
| Merge | New `shotMergeService.ts`, POST `.../shots/:shotId/merge` with `direction`, Merge button + next/previous toggle in Stage 7, `shotService.mergeShot`. |
| Robustness | Duration override (split); validation and required fields (merge); optional parse retry/Zod for split. |
| Docs | 4.3-plan and AI-agent-registry: split = stretch; add merge agent and merge behaviour. |
