The implementation plan for **Feature 4.3 (Stage 7 - Shot List Generator)** is technically comprehensive and follows the architectural patterns established in previous stages (4.1, 4.2, and 5). However, there are significant architectural risks regarding state immutability and cost management that conflict with the project's core design principles.

### **Key Flaws and Risks**

1. **Mutation vs. Immutability (High Risk)**

* **The Conflict**: The plan implements a `PUT` endpoint that updates shots in place every 500ms via auto-save. This directly violates **Core Design Principle 1: Immutability by Default**, which states "Completed stages are never mutated in place" and "Changes create new versions or branches".
* **The Danger**: Overwriting the `shots` table destroys version history. If a user makes a mistake or the LLM "hallucinates" during a split, there is no way to roll back to a prior state without a versioning system similar to the `stage_states` versioning used in Stage 5.



3. **Shot ID / Unique Constraint Conflicts**
* **The Conflict**: The database enforces `UNIQUE(scene_id, shot_id)`.
* **The Risk**: During a **Shot Split**, if the LLM generates a new `shot_id` (e.g., "1B") that already exists further down the list, the database insert will fail. The plan lacks a "re-indexing" transaction to shift existing `shot_id` and `shot_order` values before inserting new ones.


4. **Race Conditions in Auto-Save**
* **The Risk**: Rapid editing of multiple fields could trigger overlapping `PUT` requests. While the 500ms debounce helps, a slow network could cause an older state to overwrite a newer one if the requests arrive out of order at the backend.



### **What Is Solid and Well-Designed?**

* **Shot ID Algorithm**: The `{sceneNumber}{Letter}` (1A, 1B... AA) logic is robust and correctly handles edge cases where scenes have more than 26 shots.
* **Context-Aware Extraction**: The `ShotExtractionService` correctly pulls in global context (Beat Sheet) and prior scene end-states. This ensures Stage 7 maintains the "narrative continuity" required by the system.
* **Service Abstraction**: Isolating the `ShotExtractionService` and `ShotSplitService` into dedicated backend files follows the clean architecture used in Task 2 and 3.
* **RearviewMirror Integration**: Enhancing the `RearviewMirror` to use `script_excerpt` as a fallback for `end_state_summary` is a smart bridge for projects still in progress.

### **Medium / Low-Level Design Gaps**

* **Missing DELETE functionality**: The plan explicitly excludes a DELETE endpoint. Users frequently need to remove LLM-generated shots that are redundant or incorrect.
* **Batch Update for Reordering**: The current plan suggests using the `PUT` endpoint for manual reordering. This is inefficient; a dedicated "reorder" endpoint that accepts an array of IDs and their new `shot_order` would be more performant and prevent partial state corruption.
* **Validation Gaps**: The plan defines "mandatory fields" for the `shots` table but doesn't specify if the LLM extraction service validates these before attempting the database insert.

### **Summary of Soundness**

The plan is **highly sound regarding UI/UX and Agentic logic** but **architecturally inconsistent with the project's versioning requirements**. To align with the rest of the app, you should consider wrapping the shot list in a `stage_states` version or ensuring that the "Lock & Proceed" action creates a permanent, immutable snapshot of the current shot list.


# *What was Introduced to Plan*: 
Reading the plan and improvement recommendations to analyze and update the plan.

---

### 1. **Phase 10 / immutability (no change to behavior)**

- **Phase 10 alignment** subsection added right after the overview.
- It states that in-place updates (PUT auto-save, delete, split) are **in scope for 4.3**, and that full versioning, branching, and immutability will be handled in **Phase 10 (Version Control & Branching)**. No shot-level versioning or `stage_states`-style snapshots for 4.3.

So the immutability concern is **explicitly deferred** to Phase 10; the plan does not try to solve it now.

---

### 2. **Shot ID / unique constraint and split**

- **Split IDs:** Clarified that split shot IDs are **always generated server-side** as `{originalShotId}-1` and `{originalShotId}-2` (never from the LLM), so `UNIQUE(scene_id, shot_id)` is always satisfied.
- **Re-indexing:** Split endpoint (2.4) now includes a step 4: re-index `shot_order` for all shots in the scene with `shot_order > originalShot.shot_order` (increment by 1) before inserting the two new shots, so ordering stays correct and inserts don’t conflict.

---

### 3. **Race conditions (auto-save)**

- In the PUT endpoint (2.3): added an optional **optimistic locking** note (client sends `updated_at`; backend can reject if DB is newer).
- New **“Race-condition mitigation”** paragraph: either (a) optional optimistic locking, or (b) only one in-flight PUT per shot in the UI.

---

### 4. **DELETE and batch reorder**

- **Task 2.5:** New **DELETE** endpoint: `DELETE /api/projects/:id/scenes/:sceneId/shots/:shotId` with ownership checks. Plan states that the caller should reorder after delete to keep `shot_order` compact.
- **Task 2.6:** New **PUT reorder** endpoint: `PUT .../shots/reorder` with body `{ orderedShotIds: string[] }` for atomic batch reorder.
- **Task 3:** `deleteShot` now uses the API (fetch DELETE) instead of calling Supabase directly. New **`reorderShots(projectId, sceneId, orderedShotIds)`** in the frontend service.
- Top-level todos updated to “6 API endpoints” (GET, POST extract, PUT update, POST split, DELETE, PUT reorder).

---

### 5. **Validation**

- **Task 1:** New step **“Validation Before Insert”**: validate required fields (`action`, `setting`, `camera`, `duration`) on extracted shots; discard/skip invalid ones before insert and optionally flag for review.
- **Task 5 (ShotSplitService):** After building `shot1`/`shot2`, validate required fields and throw if missing so invalid LLM output is never persisted.

---

### 6. **Schema and edge cases**

- **Database:** Note that if the table doesn’t have `shot_order`, a migration must add it; it’s required for ordered fetch and split re-indexing.
- **Edge cases:** Expanded with: duplicate shot IDs (handled by server-generated IDs), auto-save out-of-order (optimistic locking / single in-flight PUT), delete then reorder, and invalid LLM output (validation before insert).
- **Notes:** Updated with Phase 10 deferral, split ID strategy, optional locking, and validation. **Key Design Decisions** updated to mention DELETE, reorder endpoint, and server-generated split IDs.

---

The plan now incorporates the second-opinion recommendations **except** full immutability/versioning, which is explicitly left for Phase 10. The document is in a consistent state for implementing 4.3 with DELETE, reorder, validation, split re-indexing, and optional race-condition handling, while keeping versioning for later.